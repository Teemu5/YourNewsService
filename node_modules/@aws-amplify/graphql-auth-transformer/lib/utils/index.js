"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getReadRolesForField = exports.getConfiguredAuthProviders = exports.getStackForField = exports.ensureAuthRuleDefaults = exports.splitRoles = void 0;
__exportStar(require("./constants"), exports);
__exportStar(require("./definitions"), exports);
__exportStar(require("./validations"), exports);
__exportStar(require("./schema"), exports);
__exportStar(require("./iam"), exports);
const splitRoles = (roles) => {
    return {
        cognitoStaticRoles: roles.filter(r => r.static && r.provider === 'userPools'),
        cognitoDynamicRoles: roles.filter(r => !r.static && r.provider === 'userPools'),
        oidcStaticRoles: roles.filter(r => r.static && r.provider === 'oidc'),
        oidcDynamicRoles: roles.filter(r => !r.static && r.provider === 'oidc'),
        iamRoles: roles.filter(r => r.provider === 'iam'),
        apiKeyRoles: roles.filter(r => r.provider === 'apiKey'),
        lambdaRoles: roles.filter(r => r.provider === 'function'),
    };
};
exports.splitRoles = splitRoles;
const ensureAuthRuleDefaults = (rules) => {
    for (const rule of rules) {
        if (!rule.provider) {
            switch (rule.allow) {
                case 'owner':
                case 'groups':
                    rule.provider = 'userPools';
                    break;
                case 'private':
                    rule.provider = 'userPools';
                    break;
                case 'public':
                    rule.provider = 'apiKey';
                    break;
                case 'custom':
                    rule.provider = 'function';
                    break;
                default:
                    throw new Error(`Need to specify an allow to assigned a provider: ${rule}`);
            }
        }
        if (rule.provider === 'iam' && !rule.generateIAMPolicy) {
            rule.generateIAMPolicy = true;
        }
    }
};
exports.ensureAuthRuleDefaults = ensureAuthRuleDefaults;
const getStackForField = (ctx, obj, fieldName, hasModelDirective) => {
    const fieldNode = obj.fields.find(f => f.name.value === fieldName);
    const fieldDirectives = fieldNode.directives.map(d => d.name.value);
    if (fieldDirectives.includes('function')) {
        return ctx.stackManager.getStack('FunctionDirectiveStack');
    }
    else if (fieldDirectives.includes('predictions')) {
        return ctx.stackManager.getStack('PredictionsDirectiveStack');
    }
    else if (hasModelDirective) {
        return ctx.stackManager.getStack(obj.name.value);
    }
    else {
        return ctx.stackManager.rootStack;
    }
};
exports.getStackForField = getStackForField;
const getConfiguredAuthProviders = (config) => {
    var _a;
    const providers = [
        config.authConfig.defaultAuthentication.authenticationType,
        ...config.authConfig.additionalAuthenticationProviders.map(p => p.authenticationType),
    ];
    const getAuthProvider = (authType) => {
        switch (authType) {
            case 'AMAZON_COGNITO_USER_POOLS':
                return 'userPools';
            case 'API_KEY':
                return 'apiKey';
            case 'AWS_IAM':
                return 'iam';
            case 'OPENID_CONNECT':
                return 'oidc';
            case 'AWS_LAMBDA':
                return 'function';
        }
    };
    const hasIAM = providers.some(p => p === 'AWS_IAM');
    const configuredProviders = {
        default: getAuthProvider(config.authConfig.defaultAuthentication.authenticationType),
        onlyDefaultAuthProviderConfigured: config.authConfig.additionalAuthenticationProviders.length === 0,
        hasAdminRolesEnabled: hasIAM && ((_a = config.adminRoles) === null || _a === void 0 ? void 0 : _a.length) > 0,
        adminRoles: config.adminRoles,
        identityPoolId: config.identityPoolId,
        hasApiKey: providers.some(p => p === 'API_KEY'),
        hasUserPools: providers.some(p => p === 'AMAZON_COGNITO_USER_POOLS'),
        hasOIDC: providers.some(p => p === 'OPENID_CONNECT'),
        hasLambda: providers.some(p => p === 'AWS_LAMBDA'),
        hasIAM,
    };
    return configuredProviders;
};
exports.getConfiguredAuthProviders = getConfiguredAuthProviders;
const getReadRolesForField = (acm, readRoles, fieldName) => {
    const hasCognitoPrivateRole = readRoles.some(r => r === 'userPools:private') && acm.isAllowed('userPools:private', fieldName, 'read');
    const hasOIDCPrivateRole = readRoles.some(r => r === 'oidc:private') && acm.isAllowed('oidc:private', fieldName, 'read');
    let allowedRoles = [...readRoles];
    if (hasCognitoPrivateRole) {
        allowedRoles = allowedRoles.filter(r => !(r.startsWith('userPools:') && r !== 'userPools:private'));
    }
    if (hasOIDCPrivateRole) {
        allowedRoles = allowedRoles.filter(r => !(r.startsWith('oidc:') && r !== 'oidc:private'));
    }
    return allowedRoles;
};
exports.getReadRolesForField = getReadRolesForField;
//# sourceMappingURL=index.js.map