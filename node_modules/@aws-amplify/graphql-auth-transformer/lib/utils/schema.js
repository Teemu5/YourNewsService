"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSubscriptionFieldNames = exports.getMutationFieldNames = exports.getQueryFieldNames = exports.addDirectivesToOperation = exports.addSubscriptionArguments = exports.addDirectivesToField = exports.extendTypeWithDirectives = exports.getTable = exports.hasRelationalDirective = exports.getRelationalPrimaryMap = exports.getSearchableConfig = exports.getModelConfig = exports.fieldIsList = exports.collectFieldNames = void 0;
const graphql_model_transformer_1 = require("@aws-amplify/graphql-model-transformer");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const constants_1 = require("./constants");
const md5_1 = __importDefault(require("md5"));
const collectFieldNames = (object) => {
    return object.fields.map((field) => field.name.value);
};
exports.collectFieldNames = collectFieldNames;
const fieldIsList = (fields, fieldName) => {
    return fields.some(field => field.name.value === fieldName && graphql_transformer_common_1.isListType(field.type));
};
exports.fieldIsList = fieldIsList;
const getModelConfig = (directive, typeName, isDataStoreEnabled = false) => {
    const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
    const options = directiveWrapped.getArguments({
        queries: {
            get: graphql_transformer_common_1.toCamelCase(['get', typeName]),
            list: graphql_transformer_common_1.toCamelCase(['list', graphql_transformer_common_1.plurality(typeName, true)]),
            ...(isDataStoreEnabled ? { sync: graphql_transformer_common_1.toCamelCase(['sync', graphql_transformer_common_1.plurality(typeName, true)]) } : undefined),
        },
        mutations: {
            create: graphql_transformer_common_1.toCamelCase(['create', typeName]),
            update: graphql_transformer_common_1.toCamelCase(['update', typeName]),
            delete: graphql_transformer_common_1.toCamelCase(['delete', typeName]),
        },
        subscriptions: {
            level: graphql_model_transformer_1.SubscriptionLevel.on,
            onCreate: [ensureValidSubscriptionName(graphql_transformer_common_1.toCamelCase(['onCreate', typeName]))],
            onDelete: [ensureValidSubscriptionName(graphql_transformer_common_1.toCamelCase(['onDelete', typeName]))],
            onUpdate: [ensureValidSubscriptionName(graphql_transformer_common_1.toCamelCase(['onUpdate', typeName]))],
        },
        timestamps: {
            createdAt: 'createdAt',
            updatedAt: 'updatedAt',
        },
    });
    return options;
};
exports.getModelConfig = getModelConfig;
const getSearchableConfig = (directive, typeName) => {
    const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
    const options = directiveWrapped.getArguments({
        queries: {
            search: graphql_transformer_common_1.graphqlName(`search${graphql_transformer_common_1.plurality(graphql_transformer_common_1.toUpper(typeName), true)}`),
        },
    });
    return options;
};
exports.getSearchableConfig = getSearchableConfig;
const getRelationalPrimaryMap = (ctx, def, field, relatedModel) => {
    const relationalDirective = field.directives.find(dir => constants_1.RELATIONAL_DIRECTIVES.includes(dir.name.value));
    const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(relationalDirective);
    const primaryFieldMap = new Map();
    if (relationalDirective.name.value === 'hasMany') {
        const args = directiveWrapped.getArguments({
            indexName: undefined,
            fields: undefined,
        });
        if (args.indexName || args.fields) {
            const fields = args.fields ? args.fields : [exports.getTable(ctx, def).keySchema.find((att) => att.keyType === 'HASH').attributeName];
            const relatedTable = args.indexName
                ? exports.getTable(ctx, relatedModel)
                    .globalSecondaryIndexes.find((gsi) => gsi.indexName === args.indexName)
                    .keySchema.map((att) => att.attributeName)
                : exports.getTable(ctx, relatedModel).keySchema.map((att) => att.attributeName);
            relatedTable.forEach((att, idx) => {
                var _a;
                primaryFieldMap.set(att, {
                    claim: fields[idx] ? 'source' : 'args',
                    field: (_a = fields[idx]) !== null && _a !== void 0 ? _a : att,
                });
            });
        }
    }
    else if (relationalDirective.name.value !== 'manyToMany') {
        const args = directiveWrapped.getArguments({
            fields: [graphql_transformer_common_1.toCamelCase([def.name.value, field.name.value, 'id'])],
        });
        const relatedPrimaryFields = exports.getTable(ctx, relatedModel).keySchema.map((att) => att.attributeName);
        if (args.fields.length !== relatedPrimaryFields.length) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Invalid @${relationalDirective.name.value} on ${def.name.value}:${field.name.value}. Provided fields do not match the size of primary key(s) for ${relatedModel.name.value}`);
        }
        relatedPrimaryFields.forEach((field, idx) => {
            primaryFieldMap.set(field, {
                claim: 'source',
                field: args.fields[idx],
            });
        });
    }
    return primaryFieldMap;
};
exports.getRelationalPrimaryMap = getRelationalPrimaryMap;
const hasRelationalDirective = (field) => {
    return field.directives && field.directives.some(dir => constants_1.RELATIONAL_DIRECTIVES.includes(dir.name.value));
};
exports.hasRelationalDirective = hasRelationalDirective;
const getTable = (ctx, def) => {
    try {
        const dbSource = ctx.dataSources.get(def);
        const tableName = graphql_transformer_common_1.ModelResourceIDs.ModelTableResourceID(def.name.value);
        return dbSource.ds.stack.node.findChild(tableName);
    }
    catch (err) {
        throw new graphql_transformer_core_1.TransformerContractError(`Could not load primary fields of @model: ${def.name.value}`);
    }
};
exports.getTable = getTable;
const extendTypeWithDirectives = (ctx, typeName, directives) => {
    let objectTypeExtension = graphql_transformer_common_1.blankObjectExtension(typeName);
    objectTypeExtension = graphql_transformer_common_1.extensionWithDirectives(objectTypeExtension, directives);
    ctx.output.addObjectExtension(objectTypeExtension);
};
exports.extendTypeWithDirectives = extendTypeWithDirectives;
const addDirectivesToField = (ctx, typeName, fieldName, directives) => {
    var _a;
    const type = ctx.output.getType(typeName);
    if (type) {
        const field = (_a = type.fields) === null || _a === void 0 ? void 0 : _a.find(f => f.name.value === fieldName);
        if (field) {
            const newFields = [...type.fields.filter(f => f.name.value !== field.name.value), graphql_transformer_common_1.extendFieldWithDirectives(field, directives)];
            const newType = {
                ...type,
                fields: newFields,
            };
            ctx.output.putType(newType);
        }
    }
};
exports.addDirectivesToField = addDirectivesToField;
const addSubscriptionArguments = (ctx, operationName, subscriptionRoles) => {
    let subscription = ctx.output.getSubscription();
    let createField = subscription.fields.find(field => field.name.value === operationName);
    const subcriptionArgumentList = subscriptionRoles.map(role => {
        return graphql_transformer_common_1.makeInputValueDefinition(role.entity, graphql_transformer_common_1.makeNamedType('String'));
    });
    createField = {
        ...createField,
        arguments: subcriptionArgumentList,
    };
    subscription = {
        ...subscription,
        fields: subscription.fields.map(field => (field.name.value === operationName ? createField : field)),
    };
    ctx.output.putType(subscription);
};
exports.addSubscriptionArguments = addSubscriptionArguments;
const addDirectivesToOperation = (ctx, typeName, operationName, directives) => {
    exports.addDirectivesToField(ctx, typeName, operationName, directives);
    const type = ctx.output.getType(typeName);
    if (type) {
        const field = type.fields.find(f => f.name.value === operationName);
        if (field) {
            const returnFieldType = field.type;
            if (returnFieldType.name) {
                const returnTypeName = returnFieldType.name.value;
                exports.extendTypeWithDirectives(ctx, returnTypeName, directives);
            }
        }
    }
};
exports.addDirectivesToOperation = addDirectivesToOperation;
const getQueryFieldNames = (modelDirectiveConfig) => {
    var _a, _b, _c;
    const fields = new Set();
    if ((_a = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _a === void 0 ? void 0 : _a.get) {
        fields.add({
            typeName: 'Query',
            fieldName: modelDirectiveConfig.queries.get,
            type: graphql_transformer_interfaces_1.QueryFieldType.GET,
        });
    }
    if ((_b = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _b === void 0 ? void 0 : _b.list) {
        fields.add({
            typeName: 'Query',
            fieldName: modelDirectiveConfig.queries.list,
            type: graphql_transformer_interfaces_1.QueryFieldType.LIST,
        });
    }
    if ((_c = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _c === void 0 ? void 0 : _c.sync) {
        fields.add({
            typeName: 'Query',
            fieldName: modelDirectiveConfig.queries.sync,
            type: graphql_transformer_interfaces_1.QueryFieldType.SYNC,
        });
    }
    return fields;
};
exports.getQueryFieldNames = getQueryFieldNames;
const getMutationFieldNames = (modelDirectiveConfig) => {
    const getMutationType = (type) => {
        switch (type) {
            case 'create':
                return graphql_transformer_interfaces_1.MutationFieldType.CREATE;
            case 'update':
                return graphql_transformer_interfaces_1.MutationFieldType.UPDATE;
            case 'delete':
                return graphql_transformer_interfaces_1.MutationFieldType.DELETE;
            default:
                throw new Error('Unknown mutation type');
        }
    };
    const fieldNames = new Set();
    for (let [mutationType, mutationName] of Object.entries((modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.mutations) || {})) {
        if (mutationName) {
            fieldNames.add({
                typeName: 'Mutation',
                fieldName: mutationName,
                type: getMutationType(mutationType),
            });
        }
    }
    return fieldNames;
};
exports.getMutationFieldNames = getMutationFieldNames;
const getSubscriptionFieldNames = (modelDirectiveConfig) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const fields = new Set();
    if (((_a = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _a === void 0 ? void 0 : _a.level) === graphql_model_transformer_1.SubscriptionLevel.on) {
        if (((_b = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _b === void 0 ? void 0 : _b.onCreate) && ((_c = modelDirectiveConfig.mutations) === null || _c === void 0 ? void 0 : _c.create)) {
            for (const fieldName of modelDirectiveConfig.subscriptions.onCreate) {
                fields.add({
                    typeName: 'Subscription',
                    fieldName: fieldName,
                });
            }
        }
        if (((_d = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _d === void 0 ? void 0 : _d.onUpdate) && ((_e = modelDirectiveConfig.mutations) === null || _e === void 0 ? void 0 : _e.update)) {
            for (const fieldName of modelDirectiveConfig.subscriptions.onUpdate) {
                fields.add({
                    typeName: 'Subscription',
                    fieldName: fieldName,
                });
            }
        }
        if (((_f = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _f === void 0 ? void 0 : _f.onDelete) && ((_g = modelDirectiveConfig.mutations) === null || _g === void 0 ? void 0 : _g.delete)) {
            for (const fieldName of modelDirectiveConfig.subscriptions.onDelete) {
                fields.add({
                    typeName: 'Subscription',
                    fieldName: fieldName,
                });
            }
        }
    }
    return fields;
};
exports.getSubscriptionFieldNames = getSubscriptionFieldNames;
const ensureValidSubscriptionName = (name) => {
    if (name.length <= 50)
        return name;
    return name.slice(0, 45) + md5_1.default(name).slice(0, 5);
};
//# sourceMappingURL=schema.js.map