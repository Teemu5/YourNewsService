"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const utils_1 = require("./utils");
const graphql_1 = require("graphql");
const graphql_model_transformer_1 = require("@aws-amplify/graphql-model-transformer");
const accesscontrol_1 = require("./accesscontrol");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const iam = __importStar(require("@aws-cdk/aws-iam"));
const cdk = __importStar(require("@aws-cdk/core"));
const resolvers_1 = require("./resolvers");
const graphql_transformer_common_2 = require("graphql-transformer-common");
const field_1 = require("./resolvers/field");
class AuthTransformer extends graphql_transformer_core_1.TransformerAuthBase {
    constructor(config = {}) {
        super('amplify-auth-transformer', utils_1.authDirectiveDefinition);
        this.authPolicyResources = new Set();
        this.unauthPolicyResources = new Set();
        this.before = (context) => {
            var _a;
            this.config.authConfig = (_a = this.config.authConfig) !== null && _a !== void 0 ? _a : context.authConfig;
            this.configuredAuthProviders = utils_1.getConfiguredAuthProviders(this.config);
        };
        this.object = (def, directive, context) => {
            var _a;
            const modelDirective = (_a = def.directives) === null || _a === void 0 ? void 0 : _a.find(dir => dir.name.value === 'model');
            if (!modelDirective) {
                throw new graphql_transformer_core_1.TransformerContractError('Types annotated with @auth must also be annotated with @model.');
            }
            const typeName = def.name.value;
            let isJoinType = false;
            if (context.metadata.has('joinTypeList')) {
                isJoinType = context.metadata.get('joinTypeList').includes(typeName);
            }
            const authDir = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const rules = authDir.getArguments({ rules: [] }).rules;
            utils_1.ensureAuthRuleDefaults(rules);
            utils_1.validateRules(rules, this.configuredAuthProviders, def.name.value);
            const acm = new accesscontrol_1.AccessControlMatrix({
                name: def.name.value,
                operations: utils_1.MODEL_OPERATIONS,
                resources: utils_1.collectFieldNames(def),
            });
            this.setAuthPolicyFlag(rules);
            this.setUnauthPolicyFlag(rules);
            this.addTypeToResourceReferences(def.name.value, rules);
            this.convertRulesToRoles(acm, rules, isJoinType);
            this.modelDirectiveConfig.set(typeName, utils_1.getModelConfig(modelDirective, typeName, context.isProjectUsingDataStore()));
            this.authModelConfig.set(typeName, acm);
        };
        this.field = (parent, field, directive, context) => {
            var _a;
            if (parent.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`The @auth directive cannot be placed on an interface's field. See ${parent.name.value}${field.name.value}`);
            }
            const isParentTypeBuiltinType = parent.name.value === context.output.getQueryTypeName() ||
                parent.name.value === context.output.getMutationTypeName() ||
                parent.name.value === context.output.getSubscriptionTypeName();
            if (isParentTypeBuiltinType) {
                console.warn(`Be careful when using @auth directives on a field in a root type. @auth directives on field definitions use the source \
object to perform authorization logic and the source will be an empty object for fields on root types. \
Static group authorization should perform as expected.`);
            }
            const modelDirective = (_a = parent.directives) === null || _a === void 0 ? void 0 : _a.find(dir => dir.name.value === 'model');
            const typeName = parent.name.value;
            const fieldName = field.name.value;
            const authDir = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const rules = authDir.getArguments({ rules: [] }).rules;
            utils_1.ensureAuthRuleDefaults(rules);
            utils_1.validateFieldRules(rules, isParentTypeBuiltinType, modelDirective !== undefined, this.configuredAuthProviders, field.name.value);
            this.setAuthPolicyFlag(rules);
            this.setUnauthPolicyFlag(rules);
            this.addFieldToResourceReferences(parent.name.value, field.name.value, rules);
            if (modelDirective) {
                let acm;
                if (!this.modelDirectiveConfig.has(typeName)) {
                    this.modelDirectiveConfig.set(typeName, utils_1.getModelConfig(modelDirective, typeName, context.isProjectUsingDataStore()));
                    acm = new accesscontrol_1.AccessControlMatrix({
                        name: parent.name.value,
                        operations: utils_1.MODEL_OPERATIONS,
                        resources: utils_1.collectFieldNames(parent),
                    });
                }
                else {
                    acm = this.authModelConfig.get(typeName);
                    acm.resetAccessForResource(fieldName);
                }
                this.convertRulesToRoles(acm, rules, false, fieldName);
                this.authModelConfig.set(typeName, acm);
            }
            else {
                const staticRules = rules.filter((rule) => rule.allow !== 'owner' && !rule.groupsField);
                const typeFieldName = `${typeName}:${fieldName}`;
                const acm = new accesscontrol_1.AccessControlMatrix({
                    name: typeFieldName,
                    operations: ['read'],
                    resources: [typeFieldName],
                });
                this.convertRulesToRoles(acm, staticRules, false, typeFieldName, ['read']);
                this.authNonModelConfig.set(typeFieldName, acm);
            }
        };
        this.transformSchema = (context) => {
            const searchableAggregateServiceDirectives = new Set();
            const getOwnerFields = (acm) => {
                return acm.getRoles().reduce((prev, role) => {
                    if (this.roleMap.get(role).strategy === 'owner')
                        prev.push(this.roleMap.get(role).entity);
                    return prev;
                }, []);
            };
            for (let [modelName, acm] of this.authModelConfig) {
                const def = context.output.getObject(modelName);
                const modelHasSearchable = def.directives.some(dir => dir.name.value === 'searchable');
                this.addFieldsToObject(context, modelName, getOwnerFields(acm));
                const providers = this.getAuthProviders(acm.getRoles());
                const directives = this.getServiceDirectives(providers, providers.length === 0 ? this.shouldAddDefaultServiceDirective() : false);
                if (modelHasSearchable) {
                    providers.forEach(p => searchableAggregateServiceDirectives.add(p));
                }
                if (directives.length > 0) {
                    utils_1.extendTypeWithDirectives(context, modelName, directives);
                }
                this.protectSchemaOperations(context, def, acm);
                this.propagateAuthDirectivesToNestedTypes(context, context.output.getObject(modelName), providers);
            }
            for (let [typeFieldName, acm] of this.authNonModelConfig) {
                const [typeName, fieldName] = typeFieldName.split(':');
                const providers = this.getAuthProviders(acm.getRoles());
                const directives = this.getServiceDirectives(providers, false);
                if (directives.length > 0) {
                    utils_1.addDirectivesToField(context, typeName, fieldName, directives);
                }
            }
            if (searchableAggregateServiceDirectives.size > 0) {
                const serviceDirectives = this.getServiceDirectives(Array.from(searchableAggregateServiceDirectives), false);
                for (let aggType of utils_1.SEARCHABLE_AGGREGATE_TYPES) {
                    utils_1.extendTypeWithDirectives(context, aggType, serviceDirectives);
                }
            }
        };
        this.generateResolvers = (context) => {
            var _a, _b;
            this.generateIAMPolicies(context);
            for (let [modelName, acm] of this.authModelConfig) {
                const indexKeyName = `${modelName}:indicies`;
                const def = context.output.getObject(modelName);
                const modelNameConfig = this.modelDirectiveConfig.get(modelName);
                const searchableDirective = def.directives.find(dir => dir.name.value === 'searchable');
                const queryFields = utils_1.getQueryFieldNames(this.modelDirectiveConfig.get(modelName));
                for (let query of queryFields.values()) {
                    switch (query.type) {
                        case graphql_transformer_interfaces_1.QueryFieldType.GET:
                            this.protectGetResolver(context, def, query.typeName, query.fieldName, acm);
                            break;
                        case graphql_transformer_interfaces_1.QueryFieldType.LIST:
                            this.protectListResolver(context, def, query.typeName, query.fieldName, acm);
                            break;
                        case graphql_transformer_interfaces_1.QueryFieldType.SYNC:
                            this.protectSyncResolver(context, def, query.typeName, query.fieldName, acm);
                            break;
                        default:
                            throw new graphql_transformer_core_1.TransformerContractError('Unkown query field type');
                    }
                }
                if (context.metadata.has(indexKeyName)) {
                    for (let index of context.metadata.get(indexKeyName).values()) {
                        const [indexName, indexQueryName] = index.split(':');
                        this.protectListResolver(context, def, def.name.value, indexQueryName, acm, indexName);
                    }
                }
                if (searchableDirective) {
                    const config = utils_1.getSearchableConfig(searchableDirective, modelName);
                    this.protectSearchResolver(context, def, context.output.getQueryTypeName(), config.queries.search, acm);
                }
                const readRoles = acm.getRolesPerOperation('read');
                const modelFields = (_b = (_a = def.fields) === null || _a === void 0 ? void 0 : _a.filter(f => acm.hasResource(f.name.value))) !== null && _b !== void 0 ? _b : [];
                const errorFields = new Array();
                for (let field of modelFields) {
                    const fieldReadRoles = utils_1.getReadRolesForField(acm, readRoles, field.name.value);
                    const allowedRoles = fieldReadRoles.filter(r => acm.isAllowed(r, field.name.value, 'read'));
                    const needsFieldResolver = allowedRoles.length < fieldReadRoles.length;
                    if (needsFieldResolver && field.type.kind === graphql_1.Kind.NON_NULL_TYPE) {
                        errorFields.push(field.name.value);
                    }
                    else if (utils_1.hasRelationalDirective(field)) {
                        this.protectRelationalResolver(context, def, modelName, field, needsFieldResolver ? allowedRoles : null);
                    }
                    else if (needsFieldResolver) {
                        this.protectFieldResolver(context, def, modelName, field.name.value, allowedRoles);
                    }
                }
                if (errorFields.length > 0 && modelNameConfig.subscriptions.level === graphql_model_transformer_1.SubscriptionLevel.on) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`Because "${def.name.value}" has a field-level authorization rule and subscriptions are enabled,` +
                        ` you need to either apply field-level authorization rules to all required fields where all rules have read access ${JSON.stringify(errorFields)}, make those fields nullable, or disable subscriptions for "${def.name.value}" (setting level to off or public).`);
                }
                const mutationFields = utils_1.getMutationFieldNames(this.modelDirectiveConfig.get(modelName));
                for (let mutation of mutationFields.values()) {
                    switch (mutation.type) {
                        case graphql_transformer_interfaces_1.MutationFieldType.CREATE:
                            this.protectCreateResolver(context, def, mutation.typeName, mutation.fieldName, acm);
                            break;
                        case graphql_transformer_interfaces_1.MutationFieldType.UPDATE:
                            this.protectUpdateResolver(context, def, mutation.typeName, mutation.fieldName, acm);
                            break;
                        case graphql_transformer_interfaces_1.MutationFieldType.DELETE:
                            this.protectDeleteResolver(context, def, mutation.typeName, mutation.fieldName, acm);
                            break;
                        default:
                            throw new graphql_transformer_core_1.TransformerContractError('Unkown Mutation field type');
                    }
                }
                const subscriptionFieldNames = utils_1.getSubscriptionFieldNames(this.modelDirectiveConfig.get(modelName));
                const subscriptionRoles = acm
                    .getRolesPerOperation('read')
                    .map(role => this.roleMap.get(role))
                    .filter(roleDef => { var _a; return (roleDef.strategy === 'owner' && !utils_1.fieldIsList((_a = def.fields) !== null && _a !== void 0 ? _a : [], roleDef.entity)) || roleDef.static; });
                for (let subscription of subscriptionFieldNames) {
                    this.protectSubscriptionResolver(context, subscription.typeName, subscription.fieldName, subscriptionRoles);
                }
            }
            for (let [typeFieldName, acm] of this.authNonModelConfig) {
                const [typeName, fieldName] = typeFieldName.split(':');
                const def = context.output.getObject(typeName);
                this.protectFieldResolver(context, def, typeName, fieldName, acm.getRoles());
            }
        };
        this.protectSchemaOperations = (ctx, def, acm) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j;
            const modelConfig = this.modelDirectiveConfig.get(def.name.value);
            const indexKeyName = `${def.name.value}:indicies`;
            const searchableDirective = def.directives.find(dir => dir.name.value === 'searchable');
            const addServiceDirective = (typeName, operation, operationName = null) => {
                if (operationName) {
                    const includeDefault = this.doesTypeHaveRulesForOperation(acm, operation);
                    const providers = this.getAuthProviders(acm.getRolesPerOperation(operation, operation === 'delete'));
                    const operationDirectives = this.getServiceDirectives(providers, includeDefault);
                    if (operationDirectives.length > 0) {
                        utils_1.addDirectivesToOperation(ctx, typeName, operationName, operationDirectives);
                    }
                    this.addOperationToResourceReferences(typeName, operationName, acm.getRoles());
                }
            };
            addServiceDirective(ctx.output.getQueryTypeName(), 'read', (_a = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.queries) === null || _a === void 0 ? void 0 : _a.get);
            addServiceDirective(ctx.output.getQueryTypeName(), 'read', (_b = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.queries) === null || _b === void 0 ? void 0 : _b.list);
            addServiceDirective(ctx.output.getQueryTypeName(), 'read', (_c = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.queries) === null || _c === void 0 ? void 0 : _c.sync);
            addServiceDirective(ctx.output.getMutationTypeName(), 'create', (_d = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.mutations) === null || _d === void 0 ? void 0 : _d.create);
            addServiceDirective(ctx.output.getMutationTypeName(), 'update', (_e = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.mutations) === null || _e === void 0 ? void 0 : _e.update);
            addServiceDirective(ctx.output.getMutationTypeName(), 'delete', (_f = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.mutations) === null || _f === void 0 ? void 0 : _f.delete);
            if (ctx.metadata.has(indexKeyName)) {
                for (let index of ctx.metadata.get(indexKeyName).values()) {
                    addServiceDirective(ctx.output.getQueryTypeName(), 'read', index.split(':')[1]);
                }
            }
            if (searchableDirective) {
                const config = utils_1.getSearchableConfig(searchableDirective, def.name.value);
                addServiceDirective(ctx.output.getQueryTypeName(), 'read', config.queries.search);
            }
            const subscriptions = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.subscriptions;
            if ((subscriptions === null || subscriptions === void 0 ? void 0 : subscriptions.level) === graphql_model_transformer_1.SubscriptionLevel.on) {
                const subscriptionArguments = acm
                    .getRolesPerOperation('read')
                    .map(role => this.roleMap.get(role))
                    .filter(roleDef => { var _a; return roleDef.strategy === 'owner' && !utils_1.fieldIsList((_a = def.fields) !== null && _a !== void 0 ? _a : [], roleDef.entity); });
                if (subscriptions.onCreate && ((_g = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.mutations) === null || _g === void 0 ? void 0 : _g.create)) {
                    for (let onCreateSub of subscriptions.onCreate) {
                        addServiceDirective(ctx.output.getSubscriptionTypeName(), 'read', onCreateSub);
                        utils_1.addSubscriptionArguments(ctx, onCreateSub, subscriptionArguments);
                    }
                }
                if (subscriptions.onUpdate && ((_h = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.mutations) === null || _h === void 0 ? void 0 : _h.update)) {
                    for (let onUpdateSub of subscriptions.onUpdate) {
                        addServiceDirective(ctx.output.getSubscriptionTypeName(), 'read', onUpdateSub);
                        utils_1.addSubscriptionArguments(ctx, onUpdateSub, subscriptionArguments);
                    }
                }
                if (subscriptions.onDelete && ((_j = modelConfig === null || modelConfig === void 0 ? void 0 : modelConfig.mutations) === null || _j === void 0 ? void 0 : _j.delete)) {
                    for (let onDeleteSub of subscriptions.onDelete) {
                        addServiceDirective(ctx.output.getSubscriptionTypeName(), 'read', onDeleteSub);
                        utils_1.addSubscriptionArguments(ctx, onDeleteSub, subscriptionArguments);
                    }
                }
            }
        };
        this.protectGetResolver = (ctx, def, typeName, fieldName, acm) => {
            var _a;
            const resolver = ctx.resolvers.getResolver(typeName, fieldName);
            const roleDefinitions = acm.getRolesPerOperation('read').map(r => this.roleMap.get(r));
            const primaryFields = utils_1.getTable(ctx, def).keySchema.map(att => att.attributeName);
            const authExpression = resolvers_1.generateAuthExpressionForQueries(this.configuredAuthProviders, roleDefinitions, (_a = def.fields) !== null && _a !== void 0 ? _a : [], primaryFields);
            resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(authExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`));
        };
        this.protectListResolver = (ctx, def, typeName, fieldName, acm, indexName) => {
            var _a;
            const resolver = ctx.resolvers.getResolver(typeName, fieldName);
            const roleDefinitions = acm.getRolesPerOperation('read').map(r => this.roleMap.get(r));
            let primaryFields;
            const table = utils_1.getTable(ctx, def);
            try {
                if (indexName) {
                    primaryFields = table.globalSecondaryIndexes
                        .find((gsi) => gsi.indexName === indexName)
                        .keySchema.map((att) => att.attributeName);
                }
                else {
                    primaryFields = table.keySchema.map((att) => att.attributeName);
                }
            }
            catch (err) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`Could not fetch keySchema for ${def.name.value}.`);
            }
            const authExpression = resolvers_1.generateAuthExpressionForQueries(this.configuredAuthProviders, roleDefinitions, (_a = def.fields) !== null && _a !== void 0 ? _a : [], primaryFields, !!indexName);
            resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(authExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`));
        };
        this.protectRelationalResolver = (ctx, def, typeName, field, fieldRoles) => {
            var _a, _b;
            let fieldAuthExpression;
            let relatedAuthExpression;
            const relatedModelObject = this.getRelatedModelObject(ctx, graphql_transformer_common_1.getBaseType(field.type));
            if (this.authModelConfig.has(relatedModelObject.name.value)) {
                const acm = this.authModelConfig.get(relatedModelObject.name.value);
                const roleDefinitions = acm.getRolesPerOperation('read').map(r => this.roleMap.get(r));
                const relationalPrimaryMap = utils_1.getRelationalPrimaryMap(ctx, def, field, relatedModelObject);
                relatedAuthExpression = resolvers_1.generateAuthExpressionForRelationQuery(this.configuredAuthProviders, roleDefinitions, (_a = relatedModelObject.fields) !== null && _a !== void 0 ? _a : [], relationalPrimaryMap);
            }
            else {
                relatedAuthExpression = field_1.generateSandboxExpressionForField(ctx.sandboxModeEnabled);
            }
            if (fieldRoles) {
                const roleDefinitions = fieldRoles.map(r => this.roleMap.get(r));
                const hasSubsEnabled = this.modelDirectiveConfig.get(typeName).subscriptions.level === 'on';
                relatedAuthExpression = resolvers_1.setDeniedFieldFlag('Mutation', hasSubsEnabled) + '\n' + relatedAuthExpression;
                fieldAuthExpression = resolvers_1.generateAuthExpressionForField(this.configuredAuthProviders, roleDefinitions, (_b = def.fields) !== null && _b !== void 0 ? _b : []);
            }
            const resolver = ctx.resolvers.getResolver(typeName, field.name.value);
            if (fieldAuthExpression) {
                resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(fieldAuthExpression, `${typeName}.${field.name.value}.{slotName}.{slotIndex}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(relatedAuthExpression, `${typeName}.${field.name.value}.{slotName}.{slotIndex}.res.vtl`));
            }
            else {
                resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(relatedAuthExpression, `${typeName}.${field.name.value}.{slotName}.{slotIndex}.req.vtl`));
            }
        };
        this.protectSyncResolver = (ctx, def, typeName, fieldName, acm) => {
            var _a;
            if (ctx.isProjectUsingDataStore()) {
                const resolver = ctx.resolvers.getResolver(typeName, fieldName);
                const roleDefinitions = acm.getRolesPerOperation('read').map(r => this.roleMap.get(r));
                const primaryFields = utils_1.getTable(ctx, def).keySchema.map(att => att.attributeName);
                const authExpression = resolvers_1.generateAuthExpressionForQueries(this.configuredAuthProviders, roleDefinitions, (_a = def.fields) !== null && _a !== void 0 ? _a : [], primaryFields);
                resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(authExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`));
            }
        };
        this.protectSearchResolver = (ctx, def, typeName, fieldName, acm) => {
            var _a;
            const acmFields = acm.getResources();
            const modelFields = (_a = def.fields) !== null && _a !== void 0 ? _a : [];
            const name = acm.getName();
            const allowedAggFields = modelFields.map(f => f.name.value).filter(f => !acmFields.includes(f));
            let leastAllowedFields = acmFields;
            const resolver = ctx.resolvers.getResolver('Search', graphql_transformer_common_2.toUpper(name));
            const readRoleDefinitions = acm.getRolesPerOperation('read').map(role => {
                const allowedFields = acmFields.filter(resource => acm.isAllowed(role, resource, 'read'));
                const roleDefinition = this.roleMap.get(role);
                if (allowedFields.length !== acmFields.length || !roleDefinition.static) {
                    roleDefinition.allowedFields = allowedFields;
                    leastAllowedFields = leastAllowedFields.filter(f => allowedFields.includes(f));
                }
                else {
                    roleDefinition.allowedFields = null;
                }
                return roleDefinition;
            });
            allowedAggFields.push(...leastAllowedFields);
            const authExpression = resolvers_1.generateAuthExpressionForSearchQueries(this.configuredAuthProviders, readRoleDefinitions, modelFields, allowedAggFields);
            resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(authExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`));
        };
        this.protectFieldResolver = (ctx, def, typeName, fieldName, roles) => {
            var _a;
            const roleDefinitions = roles.map(r => this.roleMap.get(r));
            const hasModelDirective = def.directives.some(dir => dir.name.value === 'model');
            const stack = utils_1.getStackForField(ctx, def, fieldName, hasModelDirective);
            if (ctx.api.host.hasResolver(typeName, fieldName)) {
                const fieldResolver = ctx.api.host.getResolver(typeName, fieldName);
                const fieldAuthExpression = resolvers_1.generateAuthExpressionForField(this.configuredAuthProviders, roleDefinitions, []);
                if (!ctx.api.host.hasDataSource(utils_1.NONE_DS)) {
                    ctx.api.host.addNoneDataSource(utils_1.NONE_DS);
                }
                const authFunction = ctx.api.host.addAppSyncFunction(`${graphql_transformer_common_2.toUpper(typeName)}${graphql_transformer_common_2.toUpper(fieldName)}AuthFN`, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(fieldAuthExpression, `${typeName}.${fieldName}.auth.req.vtl`), graphql_transformer_core_1.MappingTemplate.inlineTemplateFromString('$util.toJson({})'), utils_1.NONE_DS, stack);
                fieldResolver.pipelineConfig.functions.unshift(authFunction.functionId);
            }
            else {
                const fieldAuthExpression = resolvers_1.generateAuthExpressionForField(this.configuredAuthProviders, roleDefinitions, (_a = def.fields) !== null && _a !== void 0 ? _a : []);
                const subsEnabled = hasModelDirective ? this.modelDirectiveConfig.get(typeName).subscriptions.level === 'on' : false;
                const fieldResponse = resolvers_1.generateFieldAuthResponse('Mutation', fieldName, subsEnabled);
                const resolver = ctx.resolvers.addResolver(typeName, fieldName, new graphql_transformer_core_1.TransformerResolver(typeName, fieldName, graphql_transformer_common_1.ResolverResourceIDs.ResolverResourceID(typeName, fieldName), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(fieldAuthExpression, `${typeName}.${fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(fieldResponse, `${typeName}.${fieldName}.res.vtl`), ['init'], ['finish']));
                resolver.mapToStack(stack);
            }
        };
        this.protectCreateResolver = (ctx, def, typeName, fieldName, acm) => {
            var _a;
            const resolver = ctx.resolvers.getResolver(typeName, fieldName);
            const fields = acm.getResources();
            const createRoles = acm.getRolesPerOperation('create').map(role => {
                const allowedFields = fields.filter(resource => acm.isAllowed(role, resource, 'create'));
                const roleDefinition = this.roleMap.get(role);
                roleDefinition.allowedFields = allowedFields.length === fields.length ? [] : allowedFields;
                return roleDefinition;
            });
            const authExpression = resolvers_1.generateAuthExpressionForCreate(this.configuredAuthProviders, createRoles, (_a = def.fields) !== null && _a !== void 0 ? _a : []);
            resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(authExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`));
        };
        this.protectUpdateResolver = (ctx, def, typeName, fieldName, acm) => {
            var _a;
            const resolver = ctx.resolvers.getResolver(typeName, fieldName);
            const fields = acm.getResources();
            const updateDeleteRoles = [...new Set([...acm.getRolesPerOperation('update'), ...acm.getRolesPerOperation('delete')])];
            const totalRoles = updateDeleteRoles.map(role => {
                const allowedFields = fields.filter(resource => acm.isAllowed(role, resource, 'update'));
                const nullAllowedFileds = fields.filter(resource => acm.isAllowed(role, resource, 'delete'));
                const roleDefinition = this.roleMap.get(role);
                roleDefinition.allowedFields = allowedFields.length === fields.length ? [] : allowedFields;
                roleDefinition.nullAllowedFields = nullAllowedFileds.length === fields.length ? [] : nullAllowedFileds;
                return roleDefinition;
            });
            const datasource = ctx.api.host.getDataSource(`${def.name.value}Table`);
            const requestExpression = resolvers_1.generateAuthRequestExpression();
            const authExpression = resolvers_1.generateAuthExpressionForUpdate(this.configuredAuthProviders, totalRoles, (_a = def.fields) !== null && _a !== void 0 ? _a : []);
            resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(requestExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(authExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.res.vtl`), datasource);
        };
        this.protectDeleteResolver = (ctx, def, typeName, fieldName, acm) => {
            var _a;
            const resolver = ctx.resolvers.getResolver(typeName, fieldName);
            const deleteRoles = acm.getRolesPerOperation('delete', true).map(role => this.roleMap.get(role));
            const datasource = ctx.api.host.getDataSource(`${def.name.value}Table`);
            const requestExpression = resolvers_1.generateAuthRequestExpression();
            const authExpression = resolvers_1.geneateAuthExpressionForDelete(this.configuredAuthProviders, deleteRoles, (_a = def.fields) !== null && _a !== void 0 ? _a : []);
            resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(requestExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(authExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.res.vtl`), datasource);
        };
        this.protectSubscriptionResolver = (ctx, typeName, fieldName, subscriptionRoles) => {
            const resolver = ctx.resolvers.getResolver(typeName, fieldName);
            const authExpression = resolvers_1.generateAuthExpressionForSubscriptions(this.configuredAuthProviders, subscriptionRoles);
            resolver.addToSlot('auth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(authExpression, `${typeName}.${fieldName}.{slotName}.{slotIndex}.req.vtl`));
        };
        this.config = config;
        this.modelDirectiveConfig = new Map();
        this.seenNonModelTypes = new Map();
        this.authModelConfig = new Map();
        this.roleMap = new Map();
        this.generateIAMPolicyforUnauthRole = false;
        this.generateIAMPolicyforAuthRole = false;
        this.authNonModelConfig = new Map();
    }
    convertRulesToRoles(acm, authRules, allowRoleOverwrite, field, overideOperations) {
        for (let rule of authRules) {
            let operations = overideOperations ? overideOperations : rule.operations || utils_1.MODEL_OPERATIONS;
            if (rule.groups && !rule.groupsField) {
                rule.groups.forEach(group => {
                    const groupClaim = rule.groupClaim || utils_1.DEFAULT_GROUP_CLAIM;
                    const roleName = `${rule.provider}:staticGroup:${group}:${groupClaim}`;
                    if (!(roleName in this.roleMap)) {
                        this.roleMap.set(roleName, {
                            provider: rule.provider,
                            strategy: rule.allow,
                            static: true,
                            claim: groupClaim,
                            entity: group,
                        });
                    }
                    acm.setRole({ role: roleName, resource: field, operations, allowRoleOverwrite });
                });
            }
            else {
                let roleName;
                let roleDefinition;
                switch (rule.provider) {
                    case 'apiKey':
                        roleName = 'apiKey:public';
                        roleDefinition = { provider: rule.provider, strategy: rule.allow, static: true };
                        break;
                    case 'function':
                        roleName = 'function:custom';
                        roleDefinition = { provider: rule.provider, strategy: rule.allow, static: true };
                        break;
                    case 'iam':
                        roleName = `iam:${rule.allow}`;
                        roleDefinition = {
                            provider: rule.provider,
                            strategy: rule.allow,
                            static: true,
                            claim: rule.allow === 'private' ? 'authRole' : 'unauthRole',
                        };
                        break;
                    case 'oidc':
                    case 'userPools':
                        if (rule.allow === 'groups') {
                            const groupClaim = rule.groupClaim || utils_1.DEFAULT_GROUP_CLAIM;
                            const groupsField = rule.groupsField || utils_1.DEFAULT_GROUPS_FIELD;
                            roleName = `${rule.provider}:dynamicGroup:${groupsField}:${groupClaim}`;
                            roleDefinition = {
                                provider: rule.provider,
                                strategy: rule.allow,
                                static: false,
                                claim: groupClaim,
                                entity: groupsField,
                            };
                        }
                        else if (rule.allow === 'owner') {
                            const ownerField = rule.ownerField || utils_1.DEFAULT_OWNER_FIELD;
                            const ownerClaim = rule.identityClaim || utils_1.DEFAULT_IDENTITY_CLAIM;
                            roleName = `${rule.provider}:owner:${ownerField}:${ownerClaim}`;
                            roleDefinition = {
                                provider: rule.provider,
                                strategy: rule.allow,
                                static: false,
                                claim: ownerClaim,
                                entity: ownerField,
                            };
                        }
                        else if (rule.allow === 'private') {
                            roleName = `${rule.provider}:${rule.allow}`;
                            roleDefinition = {
                                provider: rule.provider,
                                strategy: rule.allow,
                                static: true,
                            };
                        }
                        else {
                            throw new graphql_transformer_core_1.TransformerContractError(`Could not create a role from ${JSON.stringify(rule)}`);
                        }
                        break;
                    default:
                        throw new graphql_transformer_core_1.TransformerContractError(`Could not create a role from ${JSON.stringify(rule)}`);
                }
                if (!(roleName in this.roleMap)) {
                    this.roleMap.set(roleName, roleDefinition);
                }
                acm.setRole({ role: roleName, resource: field, operations, allowRoleOverwrite });
            }
        }
    }
    doesTypeHaveRulesForOperation(acm, operation) {
        const rolesHasDefaultProvider = (roles) => {
            return roles.some(r => this.roleMap.get(r).provider === this.configuredAuthProviders.default);
        };
        const roles = acm.getRolesPerOperation(operation, operation === 'delete');
        return rolesHasDefaultProvider(roles) || (roles.length === 0 && this.shouldAddDefaultServiceDirective());
    }
    getAuthProviders(roles) {
        const providers = new Set();
        for (let role of roles) {
            providers.add(this.roleMap.get(role).provider);
        }
        if (this.configuredAuthProviders.hasAdminRolesEnabled) {
            providers.add('iam');
        }
        return Array.from(providers);
    }
    getRelatedModelObject(ctx, typeName) {
        const modelObjectName = graphql_transformer_common_1.ModelResourceIDs.IsModelConnectionType(typeName)
            ? graphql_transformer_common_1.ModelResourceIDs.GetModelFromConnectionType(typeName)
            : typeName;
        if (!ctx.output.hasType(modelObjectName)) {
            throw new graphql_transformer_core_1.TransformerContractError(`Could not find type: ${modelObjectName}`);
        }
        else {
            return ctx.output.getObject(modelObjectName);
        }
    }
    addFieldsToObject(ctx, modelName, ownerFields) {
        const modelObject = ctx.output.getObject(modelName);
        const existingFields = utils_1.collectFieldNames(modelObject);
        const ownerFieldsToAdd = ownerFields.filter(field => !existingFields.includes(field));
        for (let ownerField of ownerFieldsToAdd) {
            modelObject.fields.push(graphql_transformer_common_1.makeField(ownerField, [], graphql_transformer_common_1.makeNamedType('String')));
        }
        ctx.output.putType(modelObject);
    }
    propagateAuthDirectivesToNestedTypes(ctx, def, providers) {
        const nonModelTypePredicate = (fieldType) => {
            if (fieldType) {
                if (fieldType.kind !== 'ObjectTypeDefinition') {
                    return undefined;
                }
                const typeModel = fieldType.directives.find(dir => dir.name.value === 'model');
                return typeModel !== undefined ? undefined : fieldType;
            }
            return fieldType;
        };
        const nonModelFieldTypes = def
            .fields.map(f => ctx.output.getType(graphql_transformer_common_1.getBaseType(f.type)))
            .filter(nonModelTypePredicate);
        for (const nonModelFieldType of nonModelFieldTypes) {
            const nonModelName = nonModelFieldType.name.value;
            const hasSeenType = this.seenNonModelTypes.has(nonModelFieldType.name.value);
            let directives = this.getServiceDirectives(providers, hasSeenType);
            if (!hasSeenType) {
                this.seenNonModelTypes.set(nonModelName, new Set([...directives.map(dir => dir.name.value)]));
                const hasIAM = directives.some(dir => dir.name.value === 'aws_iam') || this.configuredAuthProviders.default === 'iam';
                if (hasIAM) {
                    this.unauthPolicyResources.add(`${nonModelFieldType.name.value}/null`);
                    this.authPolicyResources.add(`${nonModelFieldType.name.value}/null`);
                }
            }
            else {
                const currentDirectives = this.seenNonModelTypes.get(nonModelName);
                directives = directives.filter(dir => !currentDirectives.has(dir.name.value));
                this.seenNonModelTypes.set(nonModelName, new Set([...directives.map(dir => dir.name.value), ...currentDirectives]));
            }
            if (directives.length > 0 || !hasSeenType) {
                utils_1.extendTypeWithDirectives(ctx, nonModelFieldType.name.value, directives);
                this.propagateAuthDirectivesToNestedTypes(ctx, nonModelFieldType, providers);
            }
        }
    }
    getServiceDirectives(providers, addDefaultIfNeeded = true) {
        if (providers.length === 0) {
            return [];
        }
        const directives = new Array();
        const addDirectiveIfNeeded = (provider, directiveName) => {
            if ((this.configuredAuthProviders.default !== provider && providers.some(p => p === provider)) ||
                (this.configuredAuthProviders.default === provider && providers.some(p => p !== provider && addDefaultIfNeeded === true))) {
                directives.push(graphql_transformer_common_1.makeDirective(directiveName, []));
            }
        };
        for (let [authProvider, directiveName] of utils_1.AUTH_PROVIDER_DIRECTIVE_MAP) {
            addDirectiveIfNeeded(authProvider, directiveName);
        }
        if (providers.some(p => p === this.configuredAuthProviders.default) &&
            providers.some(p => p !== this.configuredAuthProviders.default) &&
            !directives.some(d => d.name.value === utils_1.AUTH_PROVIDER_DIRECTIVE_MAP.get(this.configuredAuthProviders.default))) {
            directives.push(graphql_transformer_common_1.makeDirective(utils_1.AUTH_PROVIDER_DIRECTIVE_MAP.get(this.configuredAuthProviders.default), []));
        }
        return directives;
    }
    shouldAddDefaultServiceDirective() {
        return (this.configuredAuthProviders.hasAdminRolesEnabled && this.config.authConfig.defaultAuthentication.authenticationType !== 'AWS_IAM');
    }
    generateIAMPolicies(ctx) {
        if (this.generateIAMPolicyforAuthRole) {
            if (this.authPolicyResources.size === 0) {
                if (!this.configuredAuthProviders.hasAdminRolesEnabled) {
                    throw new graphql_transformer_core_1.TransformerContractError('AuthRole policies should be generated, but no resources were added.');
                }
            }
            else {
                const authRoleParameter = ctx.stackManager.getParameter(graphql_transformer_core_1.IAM_AUTH_ROLE_PARAMETER).valueAsString;
                const authPolicyDocuments = utils_1.createPolicyDocumentForManagedPolicy(this.authPolicyResources);
                const rootStack = ctx.stackManager.rootStack;
                const iamAuthRoleArn = iam.Role.fromRoleArn(rootStack, 'auth-role-name', `arn:aws:iam::${cdk.Stack.of(rootStack).account}:role/${authRoleParameter}`);
                for (let i = 0; i < authPolicyDocuments.length; i++) {
                    const paddedIndex = `${i + 1}`.padStart(2, '0');
                    const resourceName = `${graphql_transformer_common_1.ResourceConstants.RESOURCES.AuthRolePolicy}${paddedIndex}`;
                    new iam.ManagedPolicy(rootStack, resourceName, {
                        document: iam.PolicyDocument.fromJson(authPolicyDocuments[i]),
                        roles: [iamAuthRoleArn],
                    });
                }
            }
        }
        if (this.generateIAMPolicyforUnauthRole) {
            if (this.unauthPolicyResources.size === 0) {
                throw new graphql_transformer_core_1.TransformerContractError('UnauthRole policies should be generated, but no resources were added');
            }
            const unauthRoleParameter = ctx.stackManager.getParameter(graphql_transformer_core_1.IAM_UNAUTH_ROLE_PARAMETER).valueAsString;
            const unauthPolicyDocuments = utils_1.createPolicyDocumentForManagedPolicy(this.unauthPolicyResources);
            const rootStack = ctx.stackManager.rootStack;
            const iamUnauthRoleArn = iam.Role.fromRoleArn(rootStack, 'unauth-role-name', `arn:aws:iam::${cdk.Stack.of(rootStack).account}:role/${unauthRoleParameter}`);
            for (let i = 0; i < unauthPolicyDocuments.length; i++) {
                const paddedIndex = `${i + 1}`.padStart(2, '0');
                const resourceName = `${graphql_transformer_common_1.ResourceConstants.RESOURCES.UnauthRolePolicy}${paddedIndex}`;
                new iam.ManagedPolicy(ctx.stackManager.rootStack, resourceName, {
                    document: iam.PolicyDocument.fromJson(unauthPolicyDocuments[i]),
                    roles: [iamUnauthRoleArn],
                });
            }
        }
    }
    setAuthPolicyFlag(rules) {
        if (rules.length === 0 || this.generateIAMPolicyforAuthRole === true) {
            return;
        }
        for (const rule of rules) {
            if ((rule.allow === 'private' || rule.allow === 'public') && rule.provider === 'iam') {
                this.generateIAMPolicyforAuthRole = true;
                return;
            }
        }
    }
    setUnauthPolicyFlag(rules) {
        if (rules.length === 0 || this.generateIAMPolicyforUnauthRole === true) {
            return;
        }
        for (const rule of rules) {
            if (rule.allow === 'public' && rule.provider === 'iam') {
                this.generateIAMPolicyforUnauthRole = true;
                return;
            }
        }
    }
    addOperationToResourceReferences(operationName, fieldName, roles) {
        const iamPublicRolesExist = roles.some(r => this.roleMap.get(r).provider === 'iam' && this.roleMap.get(r).strategy === 'public');
        const iamPrivateRolesExist = roles.some(r => this.roleMap.get(r).provider === 'iam' && this.roleMap.get(r).strategy === 'private');
        if (iamPublicRolesExist) {
            this.unauthPolicyResources.add(`${operationName}/${fieldName}`);
            this.authPolicyResources.add(`${operationName}/${fieldName}`);
        }
        if (iamPrivateRolesExist) {
            this.authPolicyResources.add(`${operationName}/${fieldName}`);
        }
    }
    addTypeToResourceReferences(typeName, rules) {
        const iamPublicRulesExist = rules.some(r => r.allow === 'public' && r.provider === 'iam' && r.generateIAMPolicy);
        const iamPrivateRulesExist = rules.some(r => r.allow === 'private' && r.provider === 'iam' && r.generateIAMPolicy);
        if (iamPublicRulesExist) {
            this.unauthPolicyResources.add(`${typeName}/null`);
            this.authPolicyResources.add(`${typeName}/null`);
        }
        if (iamPrivateRulesExist) {
            this.authPolicyResources.add(`${typeName}/null`);
        }
    }
    addFieldToResourceReferences(typeName, fieldName, rules) {
        const iamPublicRulesExist = rules.some(r => r.allow === 'public' && r.provider === 'iam' && r.generateIAMPolicy);
        const iamPrivateRulesExist = rules.some(r => r.allow === 'private' && r.provider === 'iam' && r.generateIAMPolicy);
        if (iamPublicRulesExist) {
            this.unauthPolicyResources.add(`${typeName}/${fieldName}`);
            this.authPolicyResources.add(`${typeName}/${fieldName}`);
        }
        if (iamPrivateRulesExist) {
            this.authPolicyResources.add(`${typeName}/${fieldName}`);
        }
    }
}
exports.AuthTransformer = AuthTransformer;
//# sourceMappingURL=graphql-auth-transformer.js.map