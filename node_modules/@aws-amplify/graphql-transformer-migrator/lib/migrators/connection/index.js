"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateConnection = exports.getConnectionDirective = exports.isFieldIndex = exports.getConnectionFieldsArg = exports.getFieldsWithConnection = void 0;
const graphql_transformer_common_1 = require("graphql-transformer-common");
const validConnectionDirectiveNames = new Set(['hasOne', 'hasMany', 'connection']);
function getFieldsWithConnection(fields) {
    return fields.filter((field) => field.directives.find((d) => d.name.value === 'connection'));
}
exports.getFieldsWithConnection = getFieldsWithConnection;
function getConnectionFieldsArg(connection) {
    var _a, _b, _c;
    return (_c = (_b = (_a = connection.arguments.find((a) => { var _a; return ((_a = a === null || a === void 0 ? void 0 : a.name) === null || _a === void 0 ? void 0 : _a.value) === 'fields'; })) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.values) === null || _c === void 0 ? void 0 : _c.map((v) => v.value);
}
exports.getConnectionFieldsArg = getConnectionFieldsArg;
function isFieldIndex(field) {
    return field.directives.some((dir) => dir.name.value === 'index');
}
exports.isFieldIndex = isFieldIndex;
function getConnectionDirective(field) {
    return field.directives.find((d) => d.name.value === 'connection' || d.name.value === 'hasMany' || d.name.value === 'hasOne' || d.name.value === 'belongsTo');
}
exports.getConnectionDirective = getConnectionDirective;
function getRelatedType(output, relatedTypeName) {
    const relatedType = output.definitions.find((d) => d.kind === 'ObjectTypeDefinition' && d.name.value === relatedTypeName);
    return relatedType;
}
function getFieldType(field) {
    if (field.type.kind === 'NamedType') {
        return field.type.name.value;
    }
    else {
        return getFieldType(field.type);
    }
}
function migrateConnection(node, ast) {
    const connections = getFieldsWithConnection(node.fields);
    if (connections.length === 0) {
        return;
    }
    connections.forEach((connectionField) => {
        const connectionDirective = getConnectionDirective(connectionField);
        let typeIsList = connectionField.type ? graphql_transformer_common_1.isListType(connectionField.type) : false;
        if (typeIsList) {
            connectionDirective.name.value = 'hasMany';
            const keyNameArg = connectionDirective.arguments.find((a) => a.name.value === 'keyName');
            if (keyNameArg) {
                keyNameArg.name.value = 'indexName';
            }
        }
        else {
            const relatedType = getRelatedType(ast, getFieldType(connectionField));
            const biDirectionalRelation = relatedType.fields.some((relatedField) => {
                var _a;
                if (getFieldType(relatedField) !== node.name.value) {
                    return false;
                }
                const fieldsArg = node.fields.find((f) => { var _a; return f.name.value === ((_a = getConnectionFieldsArg(connectionDirective)) === null || _a === void 0 ? void 0 : _a[0]); });
                if (fieldsArg && !isFieldIndex(fieldsArg)) {
                    return false;
                }
                return (_a = relatedField === null || relatedField === void 0 ? void 0 : relatedField.directives) === null || _a === void 0 ? void 0 : _a.some((relatedDirective) => {
                    return validConnectionDirectiveNames.has(relatedDirective.name.value);
                });
            });
            if ((biDirectionalRelation === null || biDirectionalRelation === void 0 ? void 0 : biDirectionalRelation.type) && graphql_transformer_common_1.isListType(biDirectionalRelation.type)) {
                connectionDirective.name.value = 'belongsTo';
            }
            else {
                connectionDirective.name.value = 'hasOne';
            }
        }
    });
}
exports.migrateConnection = migrateConnection;
//# sourceMappingURL=index.js.map