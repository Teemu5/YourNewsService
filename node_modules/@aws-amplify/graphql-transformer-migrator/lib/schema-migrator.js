"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateGraphQLSchema = exports.runMigration = exports.revertV2Migration = exports.attemptV2TransformerMigration = void 0;
const fs = __importStar(require("fs-extra"));
const graphql_1 = require("graphql");
const key_1 = require("./migrators/key");
const auth_1 = require("./migrators/auth");
const connection_1 = require("./migrators/connection");
const utils_1 = require("./utils");
const amplify_prompts_1 = require("amplify-prompts");
const path = __importStar(require("path"));
const schema_inspector_1 = require("./schema-inspector");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const state_migrator_1 = require("./state-migrator");
const graphql_directives_1 = require("./constants/graphql-directives");
const os = __importStar(require("os"));
const schema_backup_1 = require("./schema-backup");
const glob = __importStar(require("glob"));
const cliToMigratorAuthMap = new Map([
    ['API_KEY', 'apiKey'],
    ['AWS_IAM', 'iam'],
    ['AMAZON_COGNITO_USER_POOLS', 'userPools'],
    ['OPENID_CONNECT', 'oidc'],
]);
const MIGRATION_DOCS_URL = 'https://docs.amplify.aws/cli/migration/transformer-migration/';
async function attemptV2TransformerMigration(resourceDir, apiName, envName) {
    const schemaDocs = await getSchemaDocs(resourceDir);
    const fullSchema = utils_1.combineSchemas(schemaDocs);
    const autoMigrationDetectionResult = await canAutoMigrate(fullSchema, apiName, resourceDir);
    const postMigrationStatusMessage = await getPostMigrationStatusMessage(fullSchema, apiName);
    if (typeof autoMigrationDetectionResult === 'string') {
        amplify_prompts_1.printer.info(autoMigrationDetectionResult);
        return;
    }
    const defaultAuth = await utils_1.getDefaultAuth();
    const authMode = cliToMigratorAuthMap.get(defaultAuth);
    if (!authMode) {
        throw Error(`Unidentified authorization mode for API found: ${defaultAuth}`);
    }
    if (schemaHasComments(fullSchema)) {
        amplify_prompts_1.printer.warn(`Warning: The migration will not carry over any existing comments in your GraphQL schema, you'll be able to manually copy them in from the back-ups stored at ${schema_backup_1.backupLocation(resourceDir)}.`);
    }
    try {
        await schema_backup_1.backupSchemas(resourceDir);
        await runMigration(schemaDocs, authMode);
        await state_migrator_1.updateTransformerVersion(envName);
    }
    catch (error) {
        amplify_prompts_1.printer.error('Error encountered migrating schemas');
        amplify_prompts_1.printer.info('Restoring original schemas');
        try {
            await runRevert(resourceDir, envName);
        }
        catch (undoError) {
            amplify_prompts_1.printer.error('Error encountered restoring original schemas:');
            amplify_prompts_1.printer.info(error);
        }
        throw error;
    }
    amplify_prompts_1.printer.success('Automatic migration complete!');
    amplify_prompts_1.printer.info(`Original schemas are backed up at ${schema_backup_1.backupLocation(resourceDir)}`);
    amplify_prompts_1.printer.info(postMigrationStatusMessage);
    amplify_prompts_1.printer.info(`More migration instructions can be found at ${MIGRATION_DOCS_URL}`);
    amplify_prompts_1.printer.info(`To revert the migration run 'amplify migrate api --revert'`);
}
exports.attemptV2TransformerMigration = attemptV2TransformerMigration;
async function revertV2Migration(resourceDir, envName) {
    if (!schema_backup_1.doesBackupExist(resourceDir)) {
        amplify_prompts_1.printer.error(`No backup found at ${schema_backup_1.backupLocation(resourceDir)}`);
        return;
    }
    amplify_prompts_1.printer.warn('Reverting migration will restore all schemas to their state before `amplify migrate api`. This will wipe out any schema changes you have made since migrating.');
    if (!(await amplify_prompts_1.prompter.confirmContinue())) {
        return;
    }
    await runRevert(resourceDir, envName);
}
exports.revertV2Migration = revertV2Migration;
async function runMigration(schemas, authMode) {
    const schemaList = schemas.map(doc => doc.schema);
    const fullSchema = schemaList.join('\n');
    const fullSchemaNode = graphql_1.parse(fullSchema);
    doSchemaValidation(fullSchema);
    const newSchemaList = new Array();
    for (const doc of schemas) {
        const newSchema = await migrateGraphQLSchema(doc.schema, authMode, fullSchemaNode);
        newSchemaList.push({ schema: newSchema, filePath: doc.filePath });
    }
    await Promise.all(newSchemaList.map(doc => utils_1.replaceFile(doc.schema, doc.filePath)));
}
exports.runMigration = runMigration;
function migrateGraphQLSchema(schema, authMode, massSchema) {
    let output = graphql_1.parse(schema);
    graphql_1.visit(output, {
        ObjectTypeDefinition: {
            enter(node) {
                key_1.migrateKeys(node);
                auth_1.migrateAuth(node, authMode);
                connection_1.migrateConnection(node, massSchema);
                return node;
            },
        },
    });
    return graphql_1.print(output);
}
exports.migrateGraphQLSchema = migrateGraphQLSchema;
async function runRevert(resourceDir, envName) {
    await schema_backup_1.restoreSchemas(resourceDir);
    await state_migrator_1.revertTransformerVersion(envName);
}
function doSchemaValidation(schema) {
    const appendedSchema = schema + graphql_directives_1.GRAPHQL_DIRECTIVES_SCHEMA;
    const parsedSchema = graphql_1.parse(appendedSchema);
    let allModelDefinitions = [...parsedSchema.definitions];
    const errors = graphql_transformer_core_1.validateModelSchema({ kind: graphql_1.Kind.DOCUMENT, definitions: allModelDefinitions });
    if (errors && errors.length) {
        throw new graphql_transformer_core_1.SchemaValidationError(errors);
    }
}
async function getSchemaDocs(resourceDir) {
    const schemaFilePath = path.join(resourceDir, 'schema.graphql');
    const schemaDirectoryPath = path.join(resourceDir, 'schema');
    const schemaFileExists = fs.existsSync(schemaFilePath);
    const schemaDirectoryExists = fs.existsSync(schemaDirectoryPath);
    if (!schemaFileExists && !schemaDirectoryExists) {
        return [];
    }
    if (schemaFileExists) {
        return [{ schema: await fs.readFile(schemaFilePath, 'utf8'), filePath: schemaFilePath }];
    }
    else if (schemaDirectoryExists) {
        const schemaFiles = glob.sync('**/*.graphql', { cwd: schemaDirectoryPath }).map(fileName => path.join(schemaDirectoryPath, fileName));
        return await Promise.all(schemaFiles.map(async (fileName) => ({ schema: await fs.readFile(fileName, 'utf8'), filePath: fileName })));
    }
    return [];
}
function schemaHasComments(fullSchema) {
    return /#/.test(fullSchema);
}
async function canAutoMigrate(fullSchema, apiName, resourceDir) {
    if (schema_inspector_1.graphQLUsingSQL(apiName)) {
        return 'GraphQL APIs using Aurora RDS cannot be migrated.';
    }
    if (schema_inspector_1.isTransformerV2Enabled()) {
        return 'GraphQL Transformer version 2 is already enabled. No migration is necessary.';
    }
    if (schema_inspector_1.detectDeprecatedConnectionUsage(fullSchema)) {
        return 'You are using the deprecated parameterization of @connection which cannot be automatically migrated.';
    }
    if (schema_backup_1.doesBackupExist(resourceDir)) {
        return `A schema backup already exists at ${schema_backup_1.backupLocation(resourceDir)}. Remove or copy these files to a different location.`;
    }
    return true;
}
async function getPostMigrationStatusMessage(fullSchema, apiName) {
    const usingCustomRootTypes = schema_inspector_1.detectCustomRootTypes(graphql_1.parse(fullSchema));
    const usingOverriddenResolvers = schema_inspector_1.detectOverriddenResolvers(apiName);
    const improvedPluralizationEnabled = schema_inspector_1.isImprovedPluralizationEnabled();
    const passthroughDirectives = await schema_inspector_1.detectPassthroughDirectives(fullSchema);
    if (!usingCustomRootTypes && !usingOverriddenResolvers && passthroughDirectives.length === 0 && improvedPluralizationEnabled) {
        return '';
    }
    const messageLines = [
        'The following project state(s) were detected which may need additional attention to ensure they continue to work as expected with the new GraphQL transformer',
    ];
    if (usingCustomRootTypes) {
        messageLines.push('- You have defined custom Queries, Mutations, and/or Subscriptions in your GraphQL schema');
    }
    if (usingOverriddenResolvers) {
        messageLines.push('- You have overridden an Amplify generated resolver');
    }
    if (passthroughDirectives.length > 0) {
        messageLines.push(`- You are using the following directives which are not handled by the transformer:${os.EOL}\t${passthroughDirectives.join(', ')}`);
    }
    if (!improvedPluralizationEnabled) {
        messageLines.push('- You do not have the "improvePluralization" Feature Flag enabled');
    }
    return messageLines.join(os.EOL);
}
//# sourceMappingURL=schema-migrator.js.map