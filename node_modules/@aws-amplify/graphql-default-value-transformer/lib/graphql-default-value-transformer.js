"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultValueTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_1 = require("graphql");
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const validators_1 = require("./validators");
const directiveName = 'default';
const directiveDefinition = `
  directive @${directiveName}(value: String!) on FIELD_DEFINITION
`;
const nonStringTypes = ['Int', 'Float', 'Boolean', 'AWSTimestamp', 'AWSJSON'];
class DefaultValueTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-default-value-transformer', directiveDefinition);
        this.directiveMap = new Map();
        this.field = (parent, definition, directive, ctx) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const config = directiveWrapped.getArguments({
                object: parent,
                field: definition,
                directive,
            });
            validate(ctx, config);
            if (!this.directiveMap.has(parent.name.value)) {
                this.directiveMap.set(parent.name.value, []);
            }
            this.directiveMap.get(parent.name.value).push(config);
        };
        this.transformSchema = (ctx) => {
            for (const typeName of this.directiveMap.keys()) {
                const name = graphql_transformer_common_1.ModelResourceIDs.ModelCreateInputObjectName(typeName);
                for (const config of this.directiveMap.get(typeName)) {
                    const input = graphql_transformer_core_1.InputObjectDefinitionWrapper.fromObject(name, config.object, ctx.inputDocument);
                    const fieldWrapper = input.fields.find(f => f.name === config.field.name.value);
                    fieldWrapper === null || fieldWrapper === void 0 ? void 0 : fieldWrapper.makeNullable();
                }
            }
        };
        this.generateResolvers = (ctx) => {
            const context = ctx;
            for (const typeName of this.directiveMap.keys()) {
                const snippets = [];
                for (const config of this.directiveMap.get(typeName)) {
                    const fieldName = config.field.name.value;
                    const defaultValueArgumentValueNode = config.directive.arguments[0].value;
                    const defaultValue = defaultValueArgumentValueNode.value;
                    snippets.push(this.makeDefaultValueSnippet(fieldName, defaultValue, !nonStringTypes.includes(graphql_transformer_common_1.getBaseType(config.field.type))));
                }
                this.updateResolverWithDefaultValues(context, `create${typeName}`, snippets);
            }
        };
        this.makeDefaultValueSnippet = (fieldName, defaultValue, isString) => {
            return graphql_mapping_template_1.printBlock(`Setting "${fieldName}" to default value of "${defaultValue}"`)(graphql_mapping_template_1.qref(graphql_mapping_template_1.methodCall(graphql_mapping_template_1.ref('context.args.input.put'), graphql_mapping_template_1.str(fieldName), graphql_mapping_template_1.methodCall(graphql_mapping_template_1.ref('util.defaultIfNull'), graphql_mapping_template_1.ref(`ctx.args.input.${fieldName}`), isString ? graphql_mapping_template_1.str(defaultValue) : graphql_mapping_template_1.raw(defaultValue)))));
        };
        this.updateResolverWithDefaultValues = (ctx, resolverLogicalId, snippets) => {
            const resolver = this.getResolverObject(ctx, resolverLogicalId);
            if (resolver) {
                this.addSnippetToResolverSlot(resolver, snippets);
            }
        };
        this.getResolverObject = (ctx, resolverLogicalId) => {
            var _a;
            const objectName = ctx.output.getMutationTypeName();
            if (!objectName) {
                return null;
            }
            return (_a = ctx.resolvers.getResolver(objectName, resolverLogicalId)) !== null && _a !== void 0 ? _a : null;
        };
        this.addSnippetToResolverSlot = (resolver, snippets) => {
            const res = resolver;
            res.addToSlot('init', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(snippets.join('\n') + '\n{}', `${res.typeName}.${res.fieldName}.{slotName}.{slotIndex}.req.vtl`));
        };
    }
}
exports.DefaultValueTransformer = DefaultValueTransformer;
function validate(ctx, config) {
    validateModelDirective(config);
    validateFieldType(ctx, config.field.type);
    validateDirectiveArguments(config.directive);
    validateDefaultValueType(ctx, config);
}
function validateFieldType(ctx, type) {
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    if (graphql_transformer_common_1.isListType(type) || !graphql_transformer_common_1.isScalarOrEnum(type, enums)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive may only be added to scalar or enum field types.');
    }
}
function validateDirectiveArguments(directive) {
    if (directive.arguments.length === 0)
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive must have a value property');
    if (directive.arguments.length > 1)
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive only takes a value property');
}
function validateModelDirective(config) {
    const modelDirective = config.object.directives.find(dir => dir.name.value === 'model');
    if (!modelDirective) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive may only be added to object definitions annotated with @model.');
    }
}
function validateDefaultValueType(ctx, config) {
    if (config.value === null) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive does not support null values.');
    }
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    if (enums &&
        graphql_transformer_common_1.isEnum(config.field.type, ctx.inputDocument) &&
        !enums.find(it => it.name.value === graphql_transformer_common_1.getBaseType(config.field.type)).values.find(v => v.name.value === config.value)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Default value "${config.value}" is not a member of ${graphql_transformer_common_1.getBaseType(config.field.type)} enum.`);
    }
    const typeValidators = new validators_1.TypeValidators();
    if (!graphql_transformer_common_1.isEnum(config.field.type, ctx.inputDocument) && !typeValidators[graphql_transformer_common_1.getBaseType(config.field.type)](config.value)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Default value "${config.value}" is not a valid ${graphql_transformer_common_1.getBaseType(config.field.type)}.`);
    }
}
//# sourceMappingURL=graphql-default-value-transformer.js.map