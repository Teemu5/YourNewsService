"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateNotSelfReferencing = exports.lookupResolverName = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_common_1 = require("graphql-transformer-common");
function lookupResolverName(config, ctx, op) {
    const { object, modelDirective } = config;
    const argName = op === 'get' || op === 'list' || op === 'sync' ? 'queries' : 'mutations';
    let resolverName;
    for (const argument of modelDirective.arguments) {
        const arg = argument;
        if (arg.name.value !== argName || !Array.isArray(arg.value.fields)) {
            continue;
        }
        for (const field of arg.value.fields) {
            if (field.name.value === op) {
                resolverName = field.value.value;
                if (!resolverName) {
                    return null;
                }
            }
        }
    }
    if (!resolverName) {
        if (op === 'list' || op === 'sync') {
            resolverName = `${op}${graphql_transformer_common_1.plurality(object.name.value, true)}`;
        }
        else {
            resolverName = `${op}${object.name.value}`;
        }
    }
    return resolverName;
}
exports.lookupResolverName = lookupResolverName;
function validateNotSelfReferencing(config) {
    const { directive, field, sortKeyFields } = config;
    const fieldName = field.name.value;
    for (const sortKeyField of sortKeyFields) {
        if (sortKeyField === fieldName) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directive.name.value} field '${fieldName}' cannot reference itself.`);
        }
    }
}
exports.validateNotSelfReferencing = validateNotSelfReferencing;
//# sourceMappingURL=utils.js.map