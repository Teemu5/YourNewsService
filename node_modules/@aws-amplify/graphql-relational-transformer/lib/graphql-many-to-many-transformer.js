"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManyToManyTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const utils_1 = require("./utils");
const resolvers_1 = require("./resolvers");
const schema_1 = require("./schema");
const directiveName = 'manyToMany';
const defaultLimit = 100;
const directiveDefinition = `
  directive @${directiveName}(relationName: String!, limit: Int = ${defaultLimit}) on FIELD_DEFINITION
`;
class ManyToManyTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor(modelTransformer, indexTransformer, hasOneTransformer, authTransformer) {
        super('amplify-many-to-many-transformer', directiveDefinition);
        this.relationMap = new Map();
        this.directiveList = [];
        this.field = (parent, definition, directive, context) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const args = directiveWrapped.getArguments({
                directiveName,
                object: parent,
                field: definition,
                directive,
                limit: defaultLimit,
            });
            utils_1.validateModelDirective(args);
            args.connectionFields = [];
            if (!graphql_transformer_common_1.isListType(definition.type)) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} must be used with a list.`);
            }
            addDirectiveToRelationMap(this.relationMap, args);
            this.directiveList.push(args);
        };
        this.validate = (ctx) => {
            this.relationMap.forEach(relation => {
                const { directive1, directive2, name } = relation;
                if (!directive2) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation '${name}' must be used in exactly two locations.`);
                }
                const d1ExpectedType = graphql_transformer_common_1.getBaseType(directive1.field.type);
                const d2ExpectedType = graphql_transformer_common_1.getBaseType(directive2.field.type);
                if (d1ExpectedType !== directive2.object.name.value) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation '${name}' expects '${d1ExpectedType}' but got '${directive2.object.name.value}'.`);
                }
                if (d2ExpectedType !== directive1.object.name.value) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation '${name}' expects '${d2ExpectedType}' but got '${directive1.object.name.value}'.`);
                }
                if (ctx.output.hasType(name)) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation name '${name}' (derived from '${directive1.relationName}') already exists as a type in the schema.`);
                }
            });
        };
        this.prepare = (ctx) => {
            const context = ctx;
            if (!ctx.metadata.has('joinTypeList')) {
                ctx.metadata.set('joinTypeList', []);
            }
            this.relationMap.forEach(relation => {
                const { directive1, directive2, name } = relation;
                ctx.metadata.get('joinTypeList').push(name);
                const d1TypeName = directive1.object.name.value;
                const d2TypeName = directive2.object.name.value;
                const d1FieldName = d1TypeName.charAt(0).toLowerCase() + d1TypeName.slice(1);
                const d2FieldName = d2TypeName.charAt(0).toLowerCase() + d2TypeName.slice(1);
                const d1PartitionKey = schema_1.getPartitionKeyField(directive1.object);
                const d2PartitionKey = schema_1.getPartitionKeyField(directive2.object);
                const d1IndexName = `by${d1TypeName}`;
                const d2IndexName = `by${d2TypeName}`;
                const d1FieldNameId = `${d1FieldName}ID`;
                const d2FieldNameId = `${d2FieldName}ID`;
                const joinModelDirective = graphql_transformer_common_1.makeDirective('model', []);
                const d1IndexDirective = graphql_transformer_common_1.makeDirective('index', [
                    graphql_transformer_common_1.makeArgument('name', graphql_transformer_common_1.makeValueNode(d1IndexName)),
                    graphql_transformer_common_1.makeArgument('sortKeyFields', graphql_transformer_common_1.makeValueNode([d2FieldNameId])),
                ]);
                const d2IndexDirective = graphql_transformer_common_1.makeDirective('index', [
                    graphql_transformer_common_1.makeArgument('name', graphql_transformer_common_1.makeValueNode(d2IndexName)),
                    graphql_transformer_common_1.makeArgument('sortKeyFields', graphql_transformer_common_1.makeValueNode([d1FieldNameId])),
                ]);
                const d1HasOneDirective = graphql_transformer_common_1.makeDirective('hasOne', [graphql_transformer_common_1.makeArgument('fields', graphql_transformer_common_1.makeValueNode([d1FieldNameId]))]);
                const d2HasOneDirective = graphql_transformer_common_1.makeDirective('hasOne', [graphql_transformer_common_1.makeArgument('fields', graphql_transformer_common_1.makeValueNode([d2FieldNameId]))]);
                const d1RelatedField = graphql_transformer_common_1.makeField(d1FieldNameId, [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType(graphql_transformer_common_1.getBaseType(d1PartitionKey.type))), [d1IndexDirective]);
                const d2RelatedField = graphql_transformer_common_1.makeField(d2FieldNameId, [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType(graphql_transformer_common_1.getBaseType(d2PartitionKey.type))), [d2IndexDirective]);
                const d1Field = graphql_transformer_common_1.makeField(d1FieldName, [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType(d1TypeName)), [d1HasOneDirective]);
                const d2Field = graphql_transformer_common_1.makeField(d2FieldName, [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType(d2TypeName)), [d2HasOneDirective]);
                const joinTableDirectives = [joinModelDirective];
                const joinTableAuthDirective = createJoinTableAuthDirective(directive1.object, directive2.object);
                if (joinTableAuthDirective) {
                    joinTableDirectives.push(joinTableAuthDirective);
                }
                const joinType = {
                    ...graphql_transformer_common_1.blankObject(name),
                    fields: [graphql_transformer_common_1.makeField('id', [], graphql_transformer_common_1.wrapNonNull(graphql_transformer_common_1.makeNamedType('ID'))), d1RelatedField, d2RelatedField, d1Field, d2Field],
                    directives: joinTableDirectives,
                };
                ctx.output.addObject(joinType);
                directive1.indexName = d1IndexName;
                directive2.indexName = d2IndexName;
                directive1.fields = [d1PartitionKey.name.value];
                directive2.fields = [d1PartitionKey.name.value];
                directive1.fieldNodes = [d1PartitionKey];
                directive2.fieldNodes = [d2PartitionKey];
                directive1.relatedType = joinType;
                directive2.relatedType = joinType;
                directive1.relatedTypeIndex = [d1RelatedField];
                directive2.relatedTypeIndex = [d2RelatedField];
                this.modelTransformer.object(joinType, joinModelDirective, context);
                this.indexTransformer.field(joinType, d1RelatedField, d1IndexDirective, context);
                this.indexTransformer.field(joinType, d2RelatedField, d2IndexDirective, context);
                this.hasOneTransformer.field(joinType, d1Field, d1HasOneDirective, context);
                this.hasOneTransformer.field(joinType, d2Field, d2HasOneDirective, context);
                if (joinTableAuthDirective) {
                    this.authTransformer.object(joinType, joinTableAuthDirective, context);
                }
                context.providerRegistry.registerDataSourceProvider(joinType, this.modelTransformer);
            });
        };
        this.transformSchema = (ctx) => {
            const context = ctx;
            for (const config of this.directiveList) {
                schema_1.ensureHasManyConnectionField(config, context);
                schema_1.extendTypeWithConnection(config, context);
            }
        };
        this.generateResolvers = (ctx) => {
            const context = ctx;
            for (const config of this.directiveList) {
                resolvers_1.updateTableForConnection(config, context);
                resolvers_1.makeQueryConnectionWithKeyResolver(config, context);
            }
        };
        this.modelTransformer = modelTransformer;
        this.indexTransformer = indexTransformer;
        this.hasOneTransformer = hasOneTransformer;
        this.authTransformer = authTransformer;
    }
}
exports.ManyToManyTransformer = ManyToManyTransformer;
function addDirectiveToRelationMap(map, directive) {
    const { relationName } = directive;
    const gqlName = getGraphqlRelationName(relationName);
    let relation;
    relation = map.get(gqlName);
    if (relation === undefined) {
        relation = { name: gqlName, directive1: directive };
        map.set(gqlName, relation);
        return;
    }
    if (relation.directive2) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} relation '${relationName}' must be used in exactly two locations.`);
    }
    relation.directive2 = directive;
}
function getGraphqlRelationName(name) {
    return graphql_transformer_common_1.graphqlName(graphql_transformer_common_1.toUpper(name));
}
function createJoinTableAuthDirective(table1, table2) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const t1Auth = table1.directives.find(directive => directive.name.value === 'auth');
    const t2Auth = table2.directives.find(directive => directive.name.value === 'auth');
    const t1Rules = (_d = (_c = (_b = ((_a = t1Auth === null || t1Auth === void 0 ? void 0 : t1Auth.arguments) !== null && _a !== void 0 ? _a : []).find(arg => arg.name.value === 'rules')) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.values) !== null && _d !== void 0 ? _d : [];
    const t2Rules = (_h = (_g = (_f = ((_e = t2Auth === null || t2Auth === void 0 ? void 0 : t2Auth.arguments) !== null && _e !== void 0 ? _e : []).find(arg => arg.name.value === 'rules')) === null || _f === void 0 ? void 0 : _f.value) === null || _g === void 0 ? void 0 : _g.values) !== null && _h !== void 0 ? _h : [];
    const rules = [...t1Rules, ...t2Rules];
    if (rules.length === 0) {
        return;
    }
    return graphql_transformer_common_1.makeDirective('auth', [graphql_transformer_common_1.makeArgument('rules', { kind: graphql_1.Kind.LIST, values: rules })]);
}
//# sourceMappingURL=graphql-many-to-many-transformer.js.map