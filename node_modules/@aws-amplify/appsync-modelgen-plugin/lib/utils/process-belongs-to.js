"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBelongsToConnectedField = exports.processBelongsToConnection = void 0;
const process_connections_1 = require("./process-connections");
const process_connections_v2_1 = require("./process-connections-v2");
function processBelongsToConnection(field, model, modelMap, connectionDirective) {
    const otherSide = modelMap[field.type];
    const otherSideField = process_connections_v2_1.getConnectedFieldV2(field, model, otherSide, connectionDirective.name);
    const connectionFields = connectionDirective.arguments.fields || [];
    if (connectionFields.length > 1) {
        throw new Error('DataStore only support one key in field');
    }
    if (field.isList) {
        throw new Error(`A list field does not support the 'belongsTo' relation`);
    }
    let validOtherSideField = false;
    otherSideField.directives.forEach(dir => {
        if (dir.name === 'hasOne' || dir.name === 'hasMany') {
            validOtherSideField = true;
        }
    });
    if (!validOtherSideField) {
        throw new Error(`A 'belongsTo' field should match to a corresponding 'hasMany' or 'hasOne' field`);
    }
    const otherSideHasMany = otherSideField.isList;
    const isConnectingFieldAutoCreated = false;
    return {
        kind: process_connections_1.CodeGenConnectionType.BELONGS_TO,
        connectedModel: otherSide,
        isConnectingFieldAutoCreated,
        targetName: connectionFields[0] || (otherSideHasMany ? process_connections_1.makeConnectionAttributeName(otherSide.name, otherSideField.name) :
            process_connections_1.makeConnectionAttributeName(model.name, field.name)),
    };
}
exports.processBelongsToConnection = processBelongsToConnection;
function getBelongsToConnectedField(field, model, connectedModel) {
    let otherSideDirectives = process_connections_1.flattenFieldDirectives(connectedModel).filter(dir => {
        const connectedField = connectedModel.fields.find(connField => { return connField.name === dir.fieldName; });
        const fieldType = connectedField === null || connectedField === void 0 ? void 0 : connectedField.type;
        return ((dir.name === 'hasOne' && !(connectedField === null || connectedField === void 0 ? void 0 : connectedField.isList)) || (dir.name === 'hasMany' && (connectedField === null || connectedField === void 0 ? void 0 : connectedField.isList))) && model.name === fieldType;
    });
    if ((otherSideDirectives === null || otherSideDirectives === void 0 ? void 0 : otherSideDirectives.length) === 1) {
        return connectedModel.fields.find(connField => { return connField.name === otherSideDirectives[0].fieldName; });
    }
}
exports.getBelongsToConnectedField = getBelongsToConnectedField;
//# sourceMappingURL=process-belongs-to.js.map