"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchableModelTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const core_1 = require("@aws-cdk/core");
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const create_cfnParameters_1 = require("./cdk/create-cfnParameters");
const generate_resolver_vtl_1 = require("./generate-resolver-vtl");
const definitions_1 = require("./definitions");
const assert_1 = __importDefault(require("assert"));
const create_layer_cfnMapping_1 = require("./cdk/create-layer-cfnMapping");
const create_searchable_domain_1 = require("./cdk/create-searchable-domain");
const create_searchable_datasource_1 = require("./cdk/create-searchable-datasource");
const create_streaming_lambda_1 = require("./cdk/create-streaming-lambda");
const create_cfnOutput_1 = require("./cdk/create-cfnOutput");
const nonKeywordTypes = ['Int', 'Float', 'Boolean', 'AWSTimestamp', 'AWSDate', 'AWSDateTime'];
const STACK_NAME = 'SearchableStack';
class SearchableModelTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-searchable-transformer', `
        directive @searchable(queries: SearchableQueryMap) on OBJECT
        input SearchableQueryMap {
          search: String
        }
      `);
        this.generateResolvers = (context) => {
            var _a, _b;
            const { Env } = graphql_transformer_common_1.ResourceConstants.PARAMETERS;
            const { HasEnvironmentParameter } = graphql_transformer_common_1.ResourceConstants.CONDITIONS;
            const stack = context.stackManager.createStack(STACK_NAME);
            create_layer_cfnMapping_1.setMappings(stack);
            const envParam = context.stackManager.getParameter(Env);
            new core_1.CfnCondition(stack, HasEnvironmentParameter, {
                expression: core_1.Fn.conditionNot(core_1.Fn.conditionEquals(envParam, graphql_transformer_common_1.ResourceConstants.NONE)),
            });
            const isProjectUsingDataStore = context.isProjectUsingDataStore();
            stack.templateOptions.description = 'An auto-generated nested stack for searchable.';
            stack.templateOptions.templateFormatVersion = '2010-09-09';
            const parameterMap = create_cfnParameters_1.createParametersStack(stack);
            const domain = create_searchable_domain_1.createSearchableDomain(stack, parameterMap, context.api.apiId);
            const openSearchRole = create_searchable_domain_1.createSearchableDomainRole(context, stack, parameterMap);
            domain.grantReadWrite(openSearchRole);
            const datasource = create_searchable_datasource_1.createSearchableDataSource(stack, context.api, domain.domainEndpoint, openSearchRole, stack.parseArn(domain.domainArn).region);
            const lambdaRole = create_streaming_lambda_1.createLambdaRole(context, stack, parameterMap);
            domain.grantWrite(lambdaRole);
            const lambda = create_streaming_lambda_1.createLambda(stack, context.api, parameterMap, lambdaRole, domain.domainEndpoint, isProjectUsingDataStore, stack.parseArn(domain.domainArn).region);
            for (const def of this.searchableObjectTypeDefinitions) {
                const type = def.node.name.value;
                const fields = (_b = (_a = def.node.fields) === null || _a === void 0 ? void 0 : _a.map(f => f.name.value)) !== null && _b !== void 0 ? _b : [];
                const typeName = context.output.getQueryTypeName();
                const table = getTable(context, def.node);
                const ddbTable = table;
                assert_1.default(ddbTable);
                ddbTable.grantStreamRead(lambdaRole);
                create_streaming_lambda_1.createEventSourceMapping(stack, type, lambda, parameterMap, ddbTable.tableStreamArn);
                const { attributeName } = table.keySchema.find((att) => att.keyType === 'HASH');
                const keyFields = getKeyFields(attributeName, table);
                assert_1.default(typeName);
                const resolver = context.resolvers.generateQueryResolver(typeName, def.fieldName, graphql_transformer_common_1.ResolverResourceIDs.ElasticsearchSearchResolverResourceID(type), datasource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(generate_resolver_vtl_1.requestTemplate(attributeName, getNonKeywordFields(def.node), context.isProjectUsingDataStore(), type, keyFields), `${typeName}.${def.fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(generate_resolver_vtl_1.responseTemplate(false), `${typeName}.${def.fieldName}.res.vtl`));
                resolver.addToSlot('postAuth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(generate_resolver_vtl_1.sandboxMappingTemplate(context.sandboxModeEnabled, fields), `${typeName}.${def.fieldName}.{slotName}.{slotIndex}.res.vtl`));
                resolver.mapToStack(stack);
                context.resolvers.addResolver('Search', graphql_transformer_common_1.toUpper(type), resolver);
            }
            create_cfnOutput_1.createStackOutputs(stack, domain.domainEndpoint, context.api.apiId, domain.domainArn);
        };
        this.object = (definition, directive, ctx) => {
            var _a, _b, _c;
            const modelDirective = (_a = definition === null || definition === void 0 ? void 0 : definition.directives) === null || _a === void 0 ? void 0 : _a.find(dir => dir.name.value === 'model');
            const hasAuth = (_c = (_b = definition.directives) === null || _b === void 0 ? void 0 : _b.some(dir => dir.name.value === 'auth')) !== null && _c !== void 0 ? _c : false;
            if (!modelDirective) {
                throw new graphql_transformer_core_1.InvalidDirectiveError('Types annotated with @searchable must also be annotated with @model.');
            }
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const directiveArguments = directiveWrapped.getArguments({});
            let shouldMakeSearch = true;
            let searchFieldNameOverride = undefined;
            if (directiveArguments.queries) {
                if (!directiveArguments.queries.search) {
                    shouldMakeSearch = false;
                }
                else {
                    searchFieldNameOverride = directiveArguments.queries.search;
                }
            }
            const fieldName = searchFieldNameOverride
                ? searchFieldNameOverride
                : graphql_transformer_common_1.graphqlName(`search${graphql_transformer_common_1.plurality(graphql_transformer_common_1.toUpper(definition.name.value), true)}`);
            this.searchableObjectTypeDefinitions.push({
                node: definition,
                fieldName,
            });
            if (shouldMakeSearch) {
                this.searchableObjectNames.push(definition.name.value);
                this.generateSearchableXConnectionType(ctx, definition);
                this.generateSearchableAggregateTypes(ctx);
                const directives = [];
                if (!hasAuth && ctx.sandboxModeEnabled && ctx.authConfig.defaultAuthentication.authenticationType !== 'API_KEY') {
                    directives.push(graphql_transformer_common_1.makeDirective('aws_api_key', []));
                }
                const queryField = graphql_transformer_common_1.makeField(fieldName, [
                    graphql_transformer_common_1.makeInputValueDefinition('filter', graphql_transformer_common_1.makeNamedType(`Searchable${definition.name.value}FilterInput`)),
                    graphql_transformer_common_1.makeInputValueDefinition('sort', graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNamedType(`Searchable${definition.name.value}SortInput`))),
                    graphql_transformer_common_1.makeInputValueDefinition('limit', graphql_transformer_common_1.makeNamedType('Int')),
                    graphql_transformer_common_1.makeInputValueDefinition('nextToken', graphql_transformer_common_1.makeNamedType('String')),
                    graphql_transformer_common_1.makeInputValueDefinition('from', graphql_transformer_common_1.makeNamedType('Int')),
                    graphql_transformer_common_1.makeInputValueDefinition('aggregates', graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNamedType(`Searchable${definition.name.value}AggregationInput`))),
                ], graphql_transformer_common_1.makeNamedType(`Searchable${definition.name.value}Connection`), directives);
                ctx.output.addQueryFields([queryField]);
            }
        };
        this.transformSchema = (ctx) => {
            var _a, _b;
            for (const name of this.searchableObjectNames) {
                const searchObject = ctx.output.getObject(name);
                this.generateSearchableInputs(ctx, searchObject);
            }
            if (ctx.sandboxModeEnabled && ctx.authConfig.defaultAuthentication.authenticationType !== 'API_KEY') {
                for (let aggType of definitions_1.AGGREGATE_TYPES) {
                    const aggObject = ctx.output.getObject(aggType);
                    const hasApiKey = (_b = (_a = aggObject.directives) === null || _a === void 0 ? void 0 : _a.some(dir => dir.name.value === 'aws_api_key')) !== null && _b !== void 0 ? _b : false;
                    if (!hasApiKey) {
                        definitions_1.extendTypeWithDirectives(ctx, aggType, [graphql_transformer_common_1.makeDirective('aws_api_key', [])]);
                    }
                }
            }
        };
        this.searchableObjectTypeDefinitions = [];
        this.searchableObjectNames = [];
    }
    generateSearchableXConnectionType(ctx, definition) {
        const searchableXConnectionName = `Searchable${definition.name.value}Connection`;
        if (ctx.output.hasType(searchableXConnectionName)) {
            return;
        }
        const connectionType = graphql_transformer_common_1.blankObject(searchableXConnectionName);
        ctx.output.addObject(connectionType);
        let connectionTypeExtension = graphql_transformer_common_1.blankObjectExtension(searchableXConnectionName);
        connectionTypeExtension = graphql_transformer_common_1.extensionWithFields(connectionTypeExtension, [
            graphql_transformer_common_1.makeField('items', [], graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType(definition.name.value))))),
        ]);
        connectionTypeExtension = graphql_transformer_common_1.extensionWithFields(connectionTypeExtension, [
            graphql_transformer_common_1.makeField('nextToken', [], graphql_transformer_common_1.makeNamedType('String')),
            graphql_transformer_common_1.makeField('total', [], graphql_transformer_common_1.makeNamedType('Int')),
            graphql_transformer_common_1.makeField('aggregateItems', [], graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType(`SearchableAggregateResult`))))),
        ]);
        ctx.output.addObjectExtension(connectionTypeExtension);
    }
    generateSearchableAggregateTypes(ctx) {
        this.generateSearchableAggregateResultType(ctx);
        this.generateSearchableGenericResultType(ctx);
    }
    generateSearchableGenericResultType(ctx) {
        const searchableAggregateGenericResult = `SearchableAggregateGenericResult`;
        if (ctx.output.hasType(searchableAggregateGenericResult)) {
            return;
        }
        let searchableAggregateGenericResultNode = graphql_transformer_common_1.defineUnionType(searchableAggregateGenericResult, [
            graphql_transformer_common_1.makeNamedType(this.generateSearchableAggregateScalarResultType(ctx)),
            graphql_transformer_common_1.makeNamedType(this.generateSearchableAggregateBucketResultType(ctx)),
        ]);
        ctx.output.addUnion(searchableAggregateGenericResultNode);
    }
    generateSearchableAggregateScalarResultType(ctx) {
        const searchableAggregateScalarResult = `SearchableAggregateScalarResult`;
        if (ctx.output.hasType(searchableAggregateScalarResult)) {
            return searchableAggregateScalarResult;
        }
        const aggregateScalarType = graphql_transformer_common_1.blankObject(searchableAggregateScalarResult);
        ctx.output.addObject(aggregateScalarType);
        let aggregateScalarTypeExtension = graphql_transformer_common_1.blankObjectExtension(searchableAggregateScalarResult);
        aggregateScalarTypeExtension = graphql_transformer_common_1.extensionWithFields(aggregateScalarTypeExtension, [
            graphql_transformer_common_1.makeField('value', [], graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType('Float'))),
        ]);
        ctx.output.addObjectExtension(aggregateScalarTypeExtension);
        return searchableAggregateScalarResult;
    }
    generateSearchableAggregateBucketResultItemType(ctx) {
        const searchableAggregateBucketResultItem = `SearchableAggregateBucketResultItem`;
        if (ctx.output.hasType(searchableAggregateBucketResultItem)) {
            return searchableAggregateBucketResultItem;
        }
        const aggregateBucketResultItemType = graphql_transformer_common_1.blankObject(searchableAggregateBucketResultItem);
        ctx.output.addObject(aggregateBucketResultItemType);
        let aggregateBucketResultItemTypeExtension = graphql_transformer_common_1.blankObjectExtension(searchableAggregateBucketResultItem);
        aggregateBucketResultItemTypeExtension = graphql_transformer_common_1.extensionWithFields(aggregateBucketResultItemTypeExtension, [
            graphql_transformer_common_1.makeField('key', [], graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType('String'))),
            graphql_transformer_common_1.makeField('doc_count', [], graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType('Int'))),
        ]);
        ctx.output.addObjectExtension(aggregateBucketResultItemTypeExtension);
        return searchableAggregateBucketResultItem;
    }
    generateSearchableAggregateBucketResultType(ctx) {
        const searchableAggregateBucketResult = `SearchableAggregateBucketResult`;
        if (ctx.output.hasType(searchableAggregateBucketResult)) {
            return searchableAggregateBucketResult;
        }
        const aggregateBucketResultType = graphql_transformer_common_1.blankObject(searchableAggregateBucketResult);
        ctx.output.addObject(aggregateBucketResultType);
        this.generateSearchableAggregateBucketResultItemType(ctx);
        let aggregateBucketResultTypeExtension = graphql_transformer_common_1.blankObjectExtension(searchableAggregateBucketResult);
        aggregateBucketResultTypeExtension = graphql_transformer_common_1.extensionWithFields(aggregateBucketResultTypeExtension, [
            graphql_transformer_common_1.makeField('buckets', [], graphql_transformer_common_1.makeListType(graphql_transformer_common_1.makeNamedType('SearchableAggregateBucketResultItem'))),
        ]);
        ctx.output.addObjectExtension(aggregateBucketResultTypeExtension);
        return searchableAggregateBucketResult;
    }
    generateSearchableAggregateResultType(ctx) {
        const searchableAggregateResult = `SearchableAggregateResult`;
        if (ctx.output.hasType(searchableAggregateResult)) {
            return searchableAggregateResult;
        }
        const aggregateResultType = graphql_transformer_common_1.blankObject(searchableAggregateResult);
        ctx.output.addObject(aggregateResultType);
        let aggregateResultTypeExtension = graphql_transformer_common_1.blankObjectExtension(searchableAggregateResult);
        aggregateResultTypeExtension = graphql_transformer_common_1.extensionWithFields(aggregateResultTypeExtension, [
            graphql_transformer_common_1.makeField('name', [], graphql_transformer_common_1.makeNonNullType(graphql_transformer_common_1.makeNamedType('String'))),
            graphql_transformer_common_1.makeField('result', [], graphql_transformer_common_1.makeNamedType('SearchableAggregateGenericResult')),
        ]);
        ctx.output.addObjectExtension(aggregateResultTypeExtension);
        return searchableAggregateResult;
    }
    generateSearchableInputs(ctx, definition) {
        const inputs = Object.keys(graphql_transformer_common_1.STANDARD_SCALARS);
        inputs
            .filter(input => !ctx.output.hasType(`Searchable${input}FilterInput`))
            .map(definitions_1.makeSearchableScalarInputObject)
            .forEach((node) => ctx.output.addInput(node));
        const searchableXQueryFilterInput = definitions_1.makeSearchableXFilterInputObject(definition, ctx.inputDocument);
        if (!ctx.output.hasType(searchableXQueryFilterInput.name.value)) {
            ctx.output.addInput(searchableXQueryFilterInput);
        }
        if (!ctx.output.hasType('SearchableSortDirection')) {
            const searchableSortDirection = definitions_1.makeSearchableSortDirectionEnumObject();
            ctx.output.addEnum(searchableSortDirection);
        }
        if (!ctx.output.hasType(`Searchable${definition.name.value}SortableFields`)) {
            const searchableXSortableFieldsDirection = definitions_1.makeSearchableXSortableFieldsEnumObject(definition);
            ctx.output.addEnum(searchableXSortableFieldsDirection);
        }
        if (!ctx.output.hasType(`Searchable${definition.name.value}SortInput`)) {
            const searchableXSortableInputDirection = definitions_1.makeSearchableXSortInputObject(definition);
            ctx.output.addInput(searchableXSortableInputDirection);
        }
        if (!ctx.output.hasType('SearchableAggregateType')) {
            const searchableAggregateTypeEnum = definitions_1.makeSearchableAggregateTypeEnumObject();
            ctx.output.addEnum(searchableAggregateTypeEnum);
        }
        if (!ctx.output.hasType(`Searchable${definition.name.value}AggregateField`)) {
            const searchableXAggregationField = definitions_1.makeSearchableXAggregateFieldEnumObject(definition, ctx.inputDocument);
            ctx.output.addEnum(searchableXAggregationField);
        }
        if (!ctx.output.hasType(`Searchable${definition.name.value}AggregationInput`)) {
            const searchableXAggregationInput = definitions_1.makeSearchableXAggregationInputObject(definition);
            ctx.output.addInput(searchableXAggregationInput);
        }
    }
}
exports.SearchableModelTransformer = SearchableModelTransformer;
function getTable(context, definition) {
    const ddbDataSource = context.dataSources.get(definition);
    const tableName = graphql_transformer_common_1.ModelResourceIDs.ModelTableResourceID(definition.name.value);
    const table = ddbDataSource.ds.stack.node.findChild(tableName);
    return table;
}
function getNonKeywordFields(def) {
    var _a;
    const nonKeywordTypeSet = new Set(nonKeywordTypes);
    return ((_a = def.fields) === null || _a === void 0 ? void 0 : _a.filter(field => nonKeywordTypeSet.has(graphql_transformer_common_1.getBaseType(field.type))).map(field => graphql_mapping_template_1.str(field.name.value))) || [];
}
function getKeyFields(primaryKey, table) {
    let keyFields = [];
    keyFields.push(primaryKey);
    let { attributeName } = table.keySchema.find((att) => att.keyType === 'RANGE') || {};
    if (attributeName) {
        keyFields.push(...attributeName.split('#'));
    }
    return keyFields.map(key => graphql_mapping_template_1.str(key));
}
//# sourceMappingURL=graphql-searchable-transformer.js.map