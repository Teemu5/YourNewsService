"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeRootStackTemplate = exports.onInitSuccessful = exports.run = void 0;
const amplify_cli_core_1 = require("amplify-cli-core");
const lodash_1 = __importDefault(require("lodash"));
const override_manager_1 = require("./override-manager");
const push_resources_1 = require("./push-resources");
const template_description_utils_1 = require("./template-description-utils");
const moment = require('moment');
const path = require('path');
const glob = require('glob');
const archiver = require('./utils/archiver');
const fs = require('fs-extra');
const ora = require('ora');
const sequential = require('promise-sequential');
const Cloudformation = require('./aws-utils/aws-cfn');
const { S3 } = require('./aws-utils/aws-s3');
const constants = require('./constants');
const configurationManager = require('./configuration-manager');
const amplifyServiceManager = require('./amplify-service-manager');
const amplifyServiceMigrate = require('./amplify-service-migrate');
const { fileLogger } = require('./utils/aws-logger');
const { prePushCfnTemplateModifier } = require('./pre-push-cfn-processor/pre-push-cfn-modifier');
const logger = fileLogger('attach-backend');
const { configurePermissionsBoundaryForInit } = require('./permissions-boundary/permissions-boundary');
const { uploadHooksDirectory } = require('./utils/hooks-manager');
async function run(context) {
    await configurationManager.init(context);
    if (!context.exeInfo || context.exeInfo.isNewEnv) {
        context.exeInfo = context.exeInfo || {};
        const { projectName } = context.exeInfo.projectConfig;
        const initTemplateFilePath = path.join(__dirname, '..', 'resources', 'rootStackTemplate.json');
        const timeStamp = `${moment().format('Hmmss')}`;
        const { envName = '' } = context.exeInfo.localEnvInfo;
        let stackName = normalizeStackName(`amplify-${projectName}-${envName}-${timeStamp}`);
        const awsConfigInfo = await configurationManager.getAwsConfig(context);
        await configurePermissionsBoundaryForInit(context);
        const amplifyServiceParams = {
            context,
            awsConfigInfo,
            projectName,
            envName,
            stackName,
        };
        const { amplifyAppId, verifiedStackName, deploymentBucketName } = await amplifyServiceManager.init(amplifyServiceParams);
        stackName = verifiedStackName;
        const Tags = context.amplify.getTags(context);
        const authRoleName = `${stackName}-authRole`;
        const unauthRoleName = `${stackName}-unauthRole`;
        const rootStack = amplify_cli_core_1.JSONUtilities.readJson(initTemplateFilePath);
        await prePushCfnTemplateModifier(rootStack);
        rootStack.Description = template_description_utils_1.getDefaultTemplateDescription(context, 'root');
        const params = {
            StackName: stackName,
            Capabilities: ['CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
            TemplateBody: JSON.stringify(rootStack),
            Parameters: [
                {
                    ParameterKey: 'DeploymentBucketName',
                    ParameterValue: deploymentBucketName,
                },
                {
                    ParameterKey: 'AuthRoleName',
                    ParameterValue: authRoleName,
                },
                {
                    ParameterKey: 'UnauthRoleName',
                    ParameterValue: unauthRoleName,
                },
            ],
            Tags,
        };
        const spinner = ora();
        spinner.start('Initializing project in the cloud...');
        try {
            const cfnItem = await new Cloudformation(context, 'init', awsConfigInfo);
            const stackDescriptionData = await cfnItem.createResourceStack(params);
            processStackCreationData(context, amplifyAppId, stackDescriptionData);
            cloneCLIJSONForNewEnvironment(context);
            spinner.succeed('Successfully created initial AWS cloud resources for deployments.');
            return context;
        }
        catch (e) {
            spinner.fail('Root stack creation failed');
            throw e;
        }
    }
    else if (!context.exeInfo.isNewProject &&
        context.exeInfo.inputParams &&
        context.exeInfo.inputParams.amplify &&
        context.exeInfo.inputParams.amplify.appId) {
        await amplifyServiceMigrate.run(context);
    }
    else {
        setCloudFormationOutputInContext(context, {});
    }
}
exports.run = run;
function processStackCreationData(context, amplifyAppId, stackDescriptiondata) {
    const metadata = {};
    if (stackDescriptiondata.Stacks && stackDescriptiondata.Stacks.length) {
        const { Outputs } = stackDescriptiondata.Stacks[0];
        Outputs.forEach(element => {
            metadata[element.OutputKey] = element.OutputValue;
        });
        if (amplifyAppId) {
            metadata[constants.AmplifyAppIdLabel] = amplifyAppId;
        }
        setCloudFormationOutputInContext(context, metadata);
    }
    else {
        throw new Error('No stack data present');
    }
}
function setCloudFormationOutputInContext(context, cfnOutput) {
    lodash_1.default.set(context, ['exeInfo', 'amplifyMeta', 'providers', constants.ProviderName], cfnOutput);
    const { envName } = context.exeInfo.localEnvInfo;
    if (envName) {
        const providerInfo = lodash_1.default.get(context, ['exeInfo', 'teamProviderInfo', envName, constants.ProviderName]);
        if (providerInfo) {
            lodash_1.default.merge(providerInfo, cfnOutput);
        }
        else {
            lodash_1.default.set(context, ['exeInfo', 'teamProviderInfo', envName, constants.ProviderName], cfnOutput);
        }
    }
}
function cloneCLIJSONForNewEnvironment(context) {
    if (context.exeInfo.isNewEnv && !context.exeInfo.isNewProject) {
        const { projectPath } = context.exeInfo.localEnvInfo;
        const { envName } = amplify_cli_core_1.stateManager.getLocalEnvInfo(undefined, {
            throwIfNotExist: false,
            default: {},
        });
        if (envName) {
            const currentEnvCLIJSONPath = amplify_cli_core_1.pathManager.getCLIJSONFilePath(projectPath, envName);
            if (fs.existsSync(currentEnvCLIJSONPath)) {
                const newEnvCLIJSONPath = amplify_cli_core_1.pathManager.getCLIJSONFilePath(projectPath, context.exeInfo.localEnvInfo.envName);
                fs.copyFileSync(currentEnvCLIJSONPath, newEnvCLIJSONPath);
            }
        }
    }
}
async function onInitSuccessful(context) {
    configurationManager.onInitSuccessful(context);
    if (context.exeInfo.isNewEnv) {
        await exports.storeRootStackTemplate(context);
        context = await storeCurrentCloudBackend(context);
        await storeArtifactsForAmplifyService(context);
        await uploadHooksDirectory(context);
    }
    return context;
}
exports.onInitSuccessful = onInitSuccessful;
const storeRootStackTemplate = async (context, template) => {
    if (template === undefined) {
        template = await override_manager_1.transformRootStack(context);
    }
    await prePushCfnTemplateModifier(template);
    const projectRoot = amplify_cli_core_1.pathManager.findProjectRoot();
    const rootStackBackendBuildDir = amplify_cli_core_1.pathManager.getRootStackBuildDirPath(projectRoot);
    const rootStackCloudBackendBuildDir = amplify_cli_core_1.pathManager.getCurrentCloudRootStackDirPath(projectRoot);
    fs.ensureDirSync(rootStackBackendBuildDir);
    const rootStackBackendFilePath = path.join(rootStackBackendBuildDir, push_resources_1.rootStackFileName);
    amplify_cli_core_1.JSONUtilities.writeJson(rootStackBackendFilePath, template);
    fs.copySync(path.join(rootStackBackendBuildDir, '..'), path.join(rootStackCloudBackendBuildDir, '..'));
};
exports.storeRootStackTemplate = storeRootStackTemplate;
function storeCurrentCloudBackend(context) {
    const zipFilename = '#current-cloud-backend.zip';
    const backendDir = context.amplify.pathManager.getBackendDirPath();
    const tempDir = path.join(backendDir, '.temp');
    const currentCloudBackendDir = context.exeInfo
        ? path.join(context.exeInfo.localEnvInfo.projectPath, amplify_cli_core_1.PathConstants.AmplifyDirName, amplify_cli_core_1.PathConstants.CurrentCloudBackendDirName)
        : context.amplify.pathManager.getCurrentCloudBackendDirPath();
    if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir);
    }
    const cliJSONFiles = glob.sync(amplify_cli_core_1.PathConstants.CLIJSONFileNameGlob, {
        cwd: amplify_cli_core_1.pathManager.getAmplifyDirPath(),
        absolute: true,
    });
    const tagFilePath = amplify_cli_core_1.pathManager.getTagFilePath();
    const tagCloudFilePath = amplify_cli_core_1.pathManager.getCurrentTagFilePath();
    if (fs.existsSync(tagFilePath)) {
        fs.copySync(tagFilePath, tagCloudFilePath, { overwrite: true });
    }
    const zipFilePath = path.normalize(path.join(tempDir, zipFilename));
    let log = null;
    return archiver
        .run(currentCloudBackendDir, zipFilePath, undefined, cliJSONFiles)
        .then(result => {
        const s3Key = `${result.zipFilename}`;
        return S3.getInstance(context).then(s3 => {
            const s3Params = {
                Body: fs.createReadStream(result.zipFilePath),
                Key: s3Key,
            };
            log = logger('storeCurrentCloudBackend.s3.uploadFile', [{ Key: s3Key }]);
            log();
            return s3.uploadFile(s3Params);
        });
    })
        .catch(ex => {
        log(ex);
        throw ex;
    })
        .then(() => {
        fs.removeSync(tempDir);
        return context;
    });
}
function storeArtifactsForAmplifyService(context) {
    return S3.getInstance(context).then(async (s3) => {
        const currentCloudBackendDir = context.amplify.pathManager.getCurrentCloudBackendDirPath();
        const amplifyMetaFilePath = path.join(currentCloudBackendDir, 'amplify-meta.json');
        const backendConfigFilePath = path.join(currentCloudBackendDir, 'backend-config.json');
        const fileUploadTasks = [];
        fileUploadTasks.push(() => uploadFile(s3, amplifyMetaFilePath, 'amplify-meta.json'));
        fileUploadTasks.push(() => uploadFile(s3, backendConfigFilePath, 'backend-config.json'));
        await sequential(fileUploadTasks);
    });
}
async function uploadFile(s3, filePath, key) {
    if (fs.existsSync(filePath)) {
        const s3Params = {
            Body: fs.createReadStream(filePath),
            Key: key,
        };
        const log = logger('uploadFile.s3.uploadFile', [{ Key: key }]);
        try {
            log();
            await s3.uploadFile(s3Params);
        }
        catch (ex) {
            log(ex);
            throw ex;
        }
    }
}
function normalizeStackName(stackName) {
    let result = stackName.toLowerCase().replace(/[^-a-z0-9]/g, '');
    if (/^[^a-zA-Z]/.test(result) || result.length === 0) {
        result = `a${result}`;
    }
    return result;
}
//# sourceMappingURL=initializer.js.map