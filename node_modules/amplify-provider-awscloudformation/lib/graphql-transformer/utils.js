"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.throwIfNotJSONExt = exports.writeDeploymentToDisk = exports.mergeUserConfigWithTransformOutput = exports.readFromPath = exports.loadDiffableProject = exports.getGqlUpdatedResource = exports.getGQLDiff = exports.getAdminRoles = exports.getIdentityPoolId = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const path = __importStar(require("path"));
const rimraf_1 = __importDefault(require("rimraf"));
const constants_1 = require("../constants");
const amplify_cli_core_1 = require("amplify-cli-core");
const cloudform_1 = require("cloudform");
const deep_diff_1 = require("deep-diff");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const lodash_1 = require("lodash");
const admin_helpers_1 = require("../utils/admin-helpers");
const amplify_prompts_1 = require("amplify-prompts");
const ROOT_STACK_FILE_NAME = 'cloudformation-template.json';
const PARAMETERS_FILE_NAME = 'parameters.json';
const AMPLIFY_ADMIN_ROLE = '_Full-access/CognitoIdentityCredentials';
const AMPLIFY_MANAGE_ROLE = '_Manage-only/CognitoIdentityCredentials';
const getIdentityPoolId = async (ctx) => {
    var _a;
    const { allResources, resourcesToBeDeleted } = await ctx.amplify.getResourceStatus('auth');
    const authResources = lodash_1.pullAllBy(allResources, resourcesToBeDeleted, 'resourceName');
    const authResource = lodash_1.find(authResources, { service: 'Cognito', providerPlugin: constants_1.ProviderName });
    return (_a = authResource === null || authResource === void 0 ? void 0 : authResource.output) === null || _a === void 0 ? void 0 : _a.IdentityPoolId;
};
exports.getIdentityPoolId = getIdentityPoolId;
const getAdminRoles = async (ctx, apiResourceName) => {
    var _a, _b;
    const currentEnv = ctx.amplify.getEnvInfo().envName;
    const adminRoles = new Array();
    try {
        const amplifyMeta = amplify_cli_core_1.stateManager.getMeta();
        const appId = (_b = (_a = amplifyMeta === null || amplifyMeta === void 0 ? void 0 : amplifyMeta.providers) === null || _a === void 0 ? void 0 : _a[constants_1.ProviderName]) === null || _b === void 0 ? void 0 : _b.AmplifyAppId;
        const res = await admin_helpers_1.isAmplifyAdminApp(appId);
        if (res.userPoolID) {
            adminRoles.push(`${res.userPoolID}${AMPLIFY_ADMIN_ROLE}`, `${res.userPoolID}${AMPLIFY_MANAGE_ROLE}`);
        }
    }
    catch (err) {
    }
    const { allResources, resourcesToBeDeleted } = await ctx.amplify.getResourceStatus('function');
    const resources = lodash_1.pullAllBy(allResources, resourcesToBeDeleted, 'resourceName')
        .filter((r) => { var _a; return (_a = r.dependsOn) === null || _a === void 0 ? void 0 : _a.some((d) => (d === null || d === void 0 ? void 0 : d.resourceName) === apiResourceName); })
        .map((r) => `${r.resourceName}-${currentEnv}`);
    adminRoles.push(...resources);
    return adminRoles;
};
exports.getAdminRoles = getAdminRoles;
const getGQLDiff = (currentBackendDir, cloudBackendDir) => {
    const currentBuildDir = path.join(currentBackendDir, 'build');
    const cloudBuildDir = path.join(cloudBackendDir, 'build');
    if (fs_extra_1.default.existsSync(cloudBuildDir) && fs_extra_1.default.existsSync(currentBuildDir)) {
        const current = loadDiffableProject(cloudBuildDir, ROOT_STACK_FILE_NAME);
        const next = loadDiffableProject(currentBuildDir, ROOT_STACK_FILE_NAME);
        return { current, next, diff: deep_diff_1.diff(current, next) };
    }
    return null;
};
exports.getGQLDiff = getGQLDiff;
const getGqlUpdatedResource = (resources) => resources.find(resource => { var _a; return (resource === null || resource === void 0 ? void 0 : resource.service) === 'AppSync' && ((_a = resource === null || resource === void 0 ? void 0 : resource.providerMetadata) === null || _a === void 0 ? void 0 : _a.logicalId) && (resource === null || resource === void 0 ? void 0 : resource.providerPlugin) === 'awscloudformation'; }) || null;
exports.getGqlUpdatedResource = getGqlUpdatedResource;
function loadDiffableProject(path, rootStackName) {
    const project = readFromPath(path);
    const currentStacks = project.stacks || {};
    const diffableProject = {
        stacks: {},
        root: {},
    };
    for (const key of Object.keys(currentStacks)) {
        diffableProject.stacks[key] = amplify_cli_core_1.JSONUtilities.parse(project.stacks[key]);
    }
    if (project[rootStackName]) {
        diffableProject.root = amplify_cli_core_1.JSONUtilities.parse(project[rootStackName]);
    }
    return diffableProject;
}
exports.loadDiffableProject = loadDiffableProject;
function readFromPath(directory) {
    const pathExists = fs_extra_1.default.pathExistsSync(directory);
    if (!pathExists) {
        return;
    }
    const dirStats = fs_extra_1.default.lstatSync(directory);
    if (!dirStats.isDirectory()) {
        const buf = fs_extra_1.default.readFileSync(directory);
        return buf.toString();
    }
    const files = fs_extra_1.default.readdirSync(directory);
    const accum = {};
    for (const fileName of files) {
        const fullPath = path.join(directory, fileName);
        const value = readFromPath(fullPath);
        accum[fileName] = value;
    }
    return accum;
}
exports.readFromPath = readFromPath;
function mergeUserConfigWithTransformOutput(userConfig, transformOutput, opts) {
    const userFunctions = userConfig.functions || {};
    const userResolvers = userConfig.resolvers || {};
    const userPipelineFunctions = userConfig.pipelineFunctions || {};
    const functions = transformOutput.functions;
    const resolvers = transformOutput.resolvers;
    const pipelineFunctions = transformOutput.pipelineFunctions;
    if (!(opts === null || opts === void 0 ? void 0 : opts.disableFunctionOverrides)) {
        for (const userFunction of Object.keys(userFunctions)) {
            functions[userFunction] = userFunctions[userFunction];
        }
    }
    if (!(opts === null || opts === void 0 ? void 0 : opts.disablePipelineFunctionOverrides)) {
        const pipelineFunctionKeys = Object.keys(userPipelineFunctions);
        if (pipelineFunctionKeys.length > 0) {
            amplify_prompts_1.printer.warn(' You are using the "pipelineFunctions" directory for overridden and custom resolvers. ' +
                'Please use the "resolvers" directory as "pipelineFunctions" will be deprecated.\n');
        }
        for (const userPipelineFunction of pipelineFunctionKeys)
            resolvers[userPipelineFunction] = userPipelineFunctions[userPipelineFunction];
    }
    if (!(opts === null || opts === void 0 ? void 0 : opts.disableResolverOverrides)) {
        for (const userResolver of Object.keys(userResolvers)) {
            if (userResolver !== 'README.md') {
                resolvers[userResolver] = userResolvers[userResolver].toString();
            }
        }
    }
    const stacks = overrideUserDefinedStacks(userConfig, transformOutput);
    return {
        ...transformOutput,
        functions,
        resolvers,
        pipelineFunctions,
        stacks,
    };
}
exports.mergeUserConfigWithTransformOutput = mergeUserConfigWithTransformOutput;
function overrideUserDefinedStacks(userConfig, transformOutput) {
    const userStacks = userConfig.stacks || {};
    const { stacks, rootStack } = transformOutput;
    const resourceTypesToDependOn = {
        'AWS::CloudFormation::Stack': true,
        'AWS::AppSync::GraphQLApi': true,
        'AWS::AppSync::GraphQLSchema': true,
    };
    const allResourceIds = Object.keys(rootStack.Resources).filter((k) => {
        const resource = rootStack.Resources[k];
        return resourceTypesToDependOn[resource.Type];
    });
    const parametersKeys = Object.keys(rootStack.Parameters);
    const customStackParams = parametersKeys.reduce((acc, k) => ({
        ...acc,
        [k]: cloudform_1.Fn.Ref(k),
    }), {});
    customStackParams[graphql_transformer_common_1.ResourceConstants.PARAMETERS.AppSyncApiId] = cloudform_1.Fn.GetAtt(graphql_transformer_common_1.ResourceConstants.RESOURCES.GraphQLAPILogicalID, 'ApiId');
    let updatedParameters = rootStack.Parameters;
    for (const userStack of Object.keys(userStacks)) {
        if (stacks[userStack]) {
            throw new Error(`You cannot provide a stack named ${userStack} as it \
            will be overwritten by a stack generated by the GraphQL Transform.`);
        }
        const userDefinedStack = userStacks[userStack];
        for (const key of Object.keys(userDefinedStack.Parameters)) {
            if (customStackParams[key] == null) {
                customStackParams[key] = cloudform_1.Fn.Ref(key);
                if (updatedParameters[key])
                    throw new Error(`Cannot redefine CloudFormation parameter ${key} in stack ${userStack}.`);
                else
                    updatedParameters[key] = userDefinedStack.Parameters[key];
            }
        }
        const parametersForStack = Object.keys(userDefinedStack.Parameters).reduce((acc, k) => ({
            ...acc,
            [k]: customStackParams[k],
        }), {});
        stacks[userStack] = userDefinedStack;
        const stackResourceId = userStack.split(/[^A-Za-z]/).join('');
        const customNestedStack = new cloudform_1.CloudFormation.Stack({
            Parameters: parametersForStack,
            TemplateURL: cloudform_1.Fn.Join('/', [
                'https://s3.amazonaws.com',
                cloudform_1.Fn.Ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.S3DeploymentBucket),
                cloudform_1.Fn.Ref(graphql_transformer_common_1.ResourceConstants.PARAMETERS.S3DeploymentRootKey),
                'stacks',
                userStack,
            ]),
        }).dependsOn(allResourceIds);
        rootStack.Resources[stackResourceId] = customNestedStack;
    }
    rootStack.Parameters = updatedParameters;
    return stacks;
}
async function writeDeploymentToDisk(deployment, directory, rootStackFileName = 'rootStack.json', buildParameters, minify = false) {
    rimraf_1.default.sync(directory);
    fs_extra_1.default.ensureDirSync(directory);
    const schema = deployment.schema;
    const fullSchemaPath = path.normalize(directory + `/schema.graphql`);
    fs_extra_1.default.writeFileSync(fullSchemaPath, schema);
    initStacksAndResolversDirectories(directory);
    const resolverFileNames = Object.keys(deployment.resolvers);
    const resolverRootPath = resolverDirectoryPath(directory);
    for (const resolverFileName of resolverFileNames) {
        const fullResolverPath = path.normalize(resolverRootPath + '/' + resolverFileName);
        fs_extra_1.default.writeFileSync(fullResolverPath, deployment.resolvers[resolverFileName]);
    }
    const pipelineFunctions = Object.keys(deployment.pipelineFunctions);
    const pipelineFunctionRootPath = pipelineFunctionDirectoryPath(directory);
    for (const functionFileName of pipelineFunctions) {
        const fullTemplatePath = path.normalize(pipelineFunctionRootPath + '/' + functionFileName);
        fs_extra_1.default.writeFileSync(fullTemplatePath, deployment.pipelineFunctions[functionFileName]);
    }
    const stackNames = Object.keys(deployment.stacks);
    const stackRootPath = stacksDirectoryPath(directory);
    for (const stackFileName of stackNames) {
        const fileNameParts = stackFileName.split('.');
        if (fileNameParts.length === 1) {
            fileNameParts.push('json');
        }
        const fullFileName = fileNameParts.join('.');
        throwIfNotJSONExt(fullFileName);
        const fullStackPath = path.normalize(stackRootPath + '/' + fullFileName);
        let stackString = deployment.stacks[stackFileName];
        stackString =
            typeof stackString === 'string'
                ? deployment.stacks[stackFileName]
                : amplify_cli_core_1.JSONUtilities.stringify(deployment.stacks[stackFileName], { minify });
        fs_extra_1.default.writeFileSync(fullStackPath, stackString);
    }
    const functionNames = Object.keys(deployment.functions);
    const functionRootPath = path.normalize(directory + `/functions`);
    if (!fs_extra_1.default.existsSync(functionRootPath)) {
        fs_extra_1.default.mkdirSync(functionRootPath);
    }
    for (const functionName of functionNames) {
        const fullFunctionPath = path.normalize(functionRootPath + '/' + functionName);
        const zipContents = fs_extra_1.default.readFileSync(deployment.functions[functionName]);
        fs_extra_1.default.writeFileSync(fullFunctionPath, zipContents);
    }
    const rootStack = deployment.rootStack;
    const rootStackPath = path.normalize(directory + `/${rootStackFileName}`);
    const rootStackString = minify ? JSON.stringify(rootStack) : JSON.stringify(rootStack, null, 4);
    fs_extra_1.default.writeFileSync(rootStackPath, rootStackString);
    const jsonString = JSON.stringify(buildParameters, null, 4);
    const parametersOutputFilePath = path.join(directory, PARAMETERS_FILE_NAME);
    fs_extra_1.default.writeFileSync(parametersOutputFilePath, jsonString);
}
exports.writeDeploymentToDisk = writeDeploymentToDisk;
function initStacksAndResolversDirectories(directory) {
    const resolverRootPath = resolverDirectoryPath(directory);
    if (!fs_extra_1.default.existsSync(resolverRootPath)) {
        fs_extra_1.default.mkdirSync(resolverRootPath);
    }
    const stackRootPath = stacksDirectoryPath(directory);
    if (!fs_extra_1.default.existsSync(stackRootPath)) {
        fs_extra_1.default.mkdirSync(stackRootPath);
    }
}
function pipelineFunctionDirectoryPath(rootPath) {
    return path.normalize(path.join(rootPath, 'pipelineFunctions'));
}
function resolverDirectoryPath(rootPath) {
    return path.normalize(rootPath + `/resolvers`);
}
function stacksDirectoryPath(rootPath) {
    return path.normalize(rootPath + `/stacks`);
}
function throwIfNotJSONExt(stackFile) {
    const extension = path.extname(stackFile);
    if (extension === '.yaml' || extension === '.yml') {
        throw new Error(`Yaml is not yet supported. Please convert the CloudFormation stack ${stackFile} to json.`);
    }
    if (extension !== '.json') {
        throw new Error(`Invalid extension ${extension} for stack ${stackFile}`);
    }
}
exports.throwIfNotJSONExt = throwIfNotJSONExt;
//# sourceMappingURL=utils.js.map